# type: ignore
# pylint: disable-all
# Form implementation generated from reading ui file 'Crow Eye v14.ui'
# Do not edit this file unless you know what you are doing.

import venv
import os
import subprocess
import sys
import ctypes
import collections

def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

if os.name == 'nt':  # Check if running on Windows
    if not is_admin():
        print("This script requires administrator privileges to run. Please run as administrator.")
        # Re-run the script with admin privileges
        try:
            script = os.path.abspath(sys.argv[0])
            params = ' '.join([f'\"' + p + '\"' for p in sys.argv[1:]])
            ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, script, params, 1)
        except Exception as e:
            print(f"Failed to re-run as administrator: {e}")
        sys.exit(1)
else:
    print("This script is designed to run on Windows only.")
    

def install_initial_requirements():
    """Install colorama and setuptools before anything else."""
    initial_requirements = ['colorama', 'setuptools']
    
    for package in initial_requirements:
        try:
            subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])
            print(f'Successfully installed {package}')
        except subprocess.CalledProcessError:
            print(f'Failed to install {package}')
            sys.exit(1)

# Install initial requirements first
install_initial_requirements()

# Now we can safely import these
from colorama import init, Fore
from PyQt5.QtGui import QMovie
from PyQt5.QtCore import QObject, QThread, pyqtSignal
from PyQt5 import QtGui
import importlib.metadata

def setup_virtual_environment():
    """Create and activate virtual environment for Crow Eye."""
    init()  # Initialize colorama
    
    # Check if already in virtual environment
    if hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix):
        print(Fore.GREEN + 'Already running in virtual environment' + Fore.RESET)
        return
    
    venv_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'crow_eye_venv')
    
    # Create virtual environment if it doesn't exist
    if not os.path.exists(venv_path):
        print('Creating virtual environment...')
        try:
            venv.create(venv_path, with_pip=True)
            print(Fore.GREEN + f'Virtual environment created at {venv_path}' + Fore.RESET)
        except Exception as e:
            print(Fore.RED + f'Failed to create virtual environment: {str(e)}' + Fore.RESET)
            print(Fore.RED + 'Please check disk space and permissions' + Fore.RESET)
            input('Press Enter to continue with global Python environment...')
            return
    else:
        print(Fore.GREEN + 'Virtual environment already exists' + Fore.RESET)

    # Restart the script with the virtual environment's Python executable
    try:
        if os.name == 'nt':  # Windows
            venv_python = os.path.join(venv_path, 'Scripts', 'python.exe')
        else:  # Unix-like
            venv_python = os.path.join(venv_path, 'bin', 'python')
        
        if os.path.exists(venv_python):
            print(Fore.GREEN + 'Restarting with virtual environment...' + Fore.RESET)
            # Restart the script using the virtual environment's Python
            os.execv(venv_python, [venv_python] + sys.argv)
        else:
            print(Fore.RED + f'Virtual environment Python not found at {venv_python}' + Fore.RESET)
            input('Press Enter to continue with global Python environment...')
    except Exception as e:
        print(Fore.RED + f'Failed to restart with virtual environment: {str(e)}' + Fore.RESET)
        input('Press Enter to continue with global Python environment...')

# Setup virtual environment
setup_virtual_environment()

Crow_Eye_Requirements = [
    'PyQt5',
    'python-registry',
    'pywin32',
    'pandas',
    'streamlit',
    'altair',
    'olefile',
    'windowsprefetch'
]

def check_and_install_requirements():
    """Check and install required packages for Crow Eye application."""
    def install_package(package):
        try:
            subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])
            print(Fore.GREEN + f'Successfully installed {package}' + Fore.RESET)
            return True
        except subprocess.CalledProcessError:
            print(Fore.RED + f'Failed to install {package}' + Fore.RESET)
            return False

    missing_packages = []
    for package in Crow_Eye_Requirements:
        try:
            importlib.metadata.version(package)
            print(Fore.GREEN + f'{package} is already installed' + Fore.RESET)
        except importlib.metadata.PackageNotFoundError:
            print(Fore.RED + f'{package} is not installed' + Fore.RESET)
            missing_packages.append(package)

    if missing_packages:
        print('\nInstalling missing packages...')
        for package in missing_packages:
            install_package(package)
    else:
        print(Fore.GREEN + '\nAll required packages are installed!' + Fore.RESET)

# Check and install required packages
check_and_install_requirements()

import sqlite3
from PyQt5 import QtCore, QtGui, QtWidgets 
from PyQt5.QtWidgets import QFileDialog
import os
from PyQt5.QtWidgets import QApplication, QMainWindow, QMessageBox
from PyQt5.QtWidgets import QInputDialog, QLineEdit 
import subprocess
import shutil
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).parent.parent))
from Artifacts_Collectors import offline_RegClaw, Prefetch_claw
from subprocess import call
import GUI_resources
import json
import datetime
import Artifacts_Collectors.Prefetch_claw as Prefetch_claw
import Artifacts_Collectors.offline_RegClaw as offline_RegClaw
import Artifacts_Collectors.WinLog_Claw as WinLog_Claw
import Artifacts_Collectors.A_CJL_LNK_Claw as A_CJL_LNK_Claw
import Artifacts_Collectors.JLParser as JLParser
import Artifacts_Collectors.Regclaw as Regclaw
from PyQt5.QtCore import QObject, pyqtSignal, Qt, QTimer, QPropertyAnimation, QEasingCurve
from PyQt5.QtWidgets import QWidget, QVBoxLayout, QProgressBar, QLabel, QTextEdit, QHBoxLayout, QFrame, QSplitter
from PyQt5.QtGui import QFont, QPainter, QColor
from PyQt5 import QtCore, QtGui, QtWidgets
from styles import CrowEyeStyles

# ============================================================================
# ENHANCED UI COMPONENTS SECTION
# ============================================================================




class SearchWorker(QObject):
    finished = pyqtSignal(list)

    def __init__(self, tables, search_text):
        super().__init__()
        self.tables = tables
        self.search_text = search_text

    def run(self):
        results = []
        search_text_lower = self.search_text.lower()
        for table in self.tables:
            if not hasattr(table, 'rowCount') or not hasattr(table, 'columnCount'):
                continue
            for row in range(table.rowCount()):
                for col in range(table.columnCount()):
                    item = table.item(row, col)
                    if item and search_text_lower in item.text().lower():
                        results.append((table, row, col))
        self.finished.emit(results)

class Ui_Crow_Eye(object):  # This should be a proper Qt class, not just a plain object
    # Add data loading methods to the class

    def load_allReg_data(self):
        """Load core registry datasets into their tables from the registry DB"""
        db_path = self.get_registry_db_path() if hasattr(self, 'get_registry_db_path') else 'registry_data_live.db'
        if not os.path.exists(db_path):
            print(f"[Registry Error] Database file not found: {db_path}")
            return
    
    # ============================================================================
    # ENHANCED DATA LOADING METHODS FROM LOAD DATA.TXT
        def load_data_from_database_NetworkLists(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Network_list")
            rows = cursor.fetchall()
            self.NetworkLists_table.setRowCount(0)
            for row in rows:
                row_index = self.NetworkLists_table.rowCount()
                self.NetworkLists_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.NetworkLists_table.setItem(row_index, col_index, item)
            conn.close()
        def load_data_from_database_ComputerName(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM computer_Name")
            rows = cursor.fetchall()
            self.computerName_table.setRowCount(0)
            for row in rows:
                row_index = self.computerName_table.rowCount()
                self.computerName_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.computerName_table.setItem(row_index, col_index, item)
            conn.close()
        def load_data_from_database_Timezone(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM time_zone")
            rows = cursor.fetchall()
            self.TimeZone_table.setRowCount(0)
            for row in rows:
                row_index = self.TimeZone_table.rowCount()
                self.TimeZone_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.TimeZone_table.setItem(row_index, col_index, item)
            conn.close()

        def load_data_from_database_NetworkInterfaces(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM network_interfaces")
            rows = cursor.fetchall()
            self.NetworkInterface_table.setRowCount(0)
            for row in rows:
                row_index = self.NetworkInterface_table.rowCount()
                self.NetworkInterface_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.NetworkInterface_table.setItem(row_index, col_index, item)
            conn.close()
        def load_data_from_database_MachineRune(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM machine_run")
            rows = cursor.fetchall()
            self.MachineRun_table.setRowCount(0)
            for row in rows:
                row_index = self.MachineRun_table.rowCount()
                self.MachineRun_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.MachineRun_table.setItem(row_index, col_index, item)
            conn.close()        
        
        def load_data_from_database_MachineRuneOnce(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM machine_run_once")
            rows = cursor.fetchall()
            self.MachineRunOnce_tabel.setRowCount(0)
            for row in rows:
                row_index = self.MachineRunOnce_tabel.rowCount()
                self.MachineRunOnce_tabel.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.MachineRunOnce_tabel.setItem(row_index, col_index, item)
            conn.close()                
        def load_data_from_database_UserRun(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM user_run")
            rows = cursor.fetchall()
            self.UserRun_table.setRowCount(0)
            for row in rows:
                row_index = self.UserRun_table.rowCount()
                self.UserRun_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.UserRun_table.setItem(row_index, col_index, item)
            conn.close()   
        def load_data_from_database_UserRunOnce(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM user_run_once")
            rows = cursor.fetchall()
            self.UserRunOnce_table.setRowCount(0)
            for row in rows:
                row_index = self.UserRunOnce_table.rowCount()
                self.UserRunOnce_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.UserRunOnce_table.setItem(row_index, col_index, item)
            conn.close() 
        def load_data_from_database_LastUpdate(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Windows_lastupdate")
            rows = cursor.fetchall()
            self.LastUpdate_table.setRowCount(0)
            for row in rows:
                row_index = self.LastUpdate_table.rowCount()
                self.LastUpdate_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.LastUpdate_table.setItem(row_index, col_index, item)
            conn.close()        
        def load_data_from_database_LastUpdate_subkeys(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Windows_lastupdate")
            rows = cursor.fetchall()
            self.LastUpdateInfo_table.setRowCount(0)
            for row in rows:
                row_index = self.LastUpdateInfo_table.rowCount()
                self.LastUpdateInfo_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.LastUpdateInfo_table.setItem(row_index, col_index, item)
            conn.close() 
        def load_data_from_database_shutdowninfo(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Windows_lastupdate")
            rows = cursor.fetchall()
            self.ShutDown_table.setRowCount(0)
            for row in rows:
                row_index = self.ShutDown_table.rowCount()
                self.ShutDown_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.ShutDown_table.setItem(row_index, col_index, item)
            conn.close()
        def load_data_from_database_RecentDocs(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM RecentDocs")
            rows = cursor.fetchall()
            self.RecentDocs_table.setRowCount(0)
            for row in rows:
                row_index = self.RecentDocs_table.rowCount()
                self.RecentDocs_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.RecentDocs_table.setItem(row_index, col_index, item)
            conn.close()
        
        def load_data_from_database_search_explorer_bar(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Search_Explorer_bar")
            rows = cursor.fetchall()
            self.SearchViaExplorer_table.setRowCount(0)
            for row in rows:
                row_index = self.SearchViaExplorer_table.rowCount()
                self.SearchViaExplorer_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.SearchViaExplorer_table.setItem(row_index, col_index, item)
            conn.close()
        def load_data_from_database_OpenSaveMRU(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM OpenSaveMRU")
            rows = cursor.fetchall()
            self.OpenSaveMRU_table.setRowCount(0)
            for row in rows:
                row_index = self.OpenSaveMRU_table.rowCount()
                self.OpenSaveMRU_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.OpenSaveMRU_table.setItem(row_index, col_index, item)
            conn.close()
            
        def load_data_from_database_LastSaveMRU(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM lastSaveMRU")
            rows = cursor.fetchall()
            self.LastSaveMRU_table.setRowCount(0)
            for row in rows:
                row_index = self.LastSaveMRU_table.rowCount()
                self.LastSaveMRU_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.LastSaveMRU_table.setItem(row_index, col_index, item)
            conn.close()
        def load_data_from_database_TypedPathes(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM TypedPaths")
            rows = cursor.fetchall()
            self.TypedPath_table.setRowCount(0)
            for row in rows:
                row_index = self.TypedPath_table.rowCount()
                self.TypedPath_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.TypedPath_table.setItem(row_index, col_index, item)
            conn.close()
        
        def load_data_from_database_BAM(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM BAM")
            rows = cursor.fetchall()
            self.Bam_table.setRowCount(0)
            for row in rows:
                row_index = self.Bam_table.rowCount()
                self.Bam_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.Bam_table.setItem(row_index, col_index, item)
            conn.close()
        
        def load_data_from_database_DAM(self):
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM DAM")
            rows = cursor.fetchall()
            self.Dam_table.setRowCount(0)
            for row in rows:
                row_index = self.Dam_table.rowCount()
                self.Dam_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.Dam_table.setItem(row_index, col_index, item)
            conn.close()
        
                                
        def load_data_from_database_lnkAJL(self):
            conn = sqlite3.connect('LnkDB.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM JLCE")
            rows = cursor.fetchall()
            self.LNK_table.setRowCount(0)
            for row in rows:
                row_index = self.LNK_table.rowCount()
                self.LNK_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.LNK_table.setItem(row_index, col_index, item)
            conn.close()
        
        def load_data_from_database_CJL(self):
            conn = sqlite3.connect('LnkDB.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Custom_JLCE")
            rows = cursor.fetchall()
            # Populate the table widget with data from the database
            self.Clj_table.setRowCount(0)
            for row in rows:
                row_index = self.Clj_table.rowCount()
                self.Clj_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.Clj_table.setItem(row_index, col_index, item)

            conn.close()

        def load_data_from_SystemLogs(self):
            conn = sqlite3.connect('Log_Claw.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM SystemLogs")
            rows = cursor.fetchall()
            # Populate the table widget with data from the database
            self.tableWidget_22.setRowCount(0)
            for row in rows:
                row_index = self.tableWidget_22.rowCount()
                self.tableWidget_22.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.tableWidget_22.setItem(row_index, col_index, item)

            conn.close()
        
        def load_data_from_appsLogs(self):
            conn = sqlite3.connect('Log_Claw.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM ApplicationLogs")
            rows = cursor.fetchall()
            # Populate the table widget with data from the database
            self.AppLogs_table.setRowCount(0)
            for row in rows:
                row_index = self.AppLogs_table.rowCount()
                self.AppLogs_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.AppLogs_table.setItem(row_index, col_index, item)

            conn.close()
        def load_data_from_SecurityLogs(self):
            conn = sqlite3.connect('Log_Claw.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM SecurityLogs")
            rows = cursor.fetchall()
            # Populate the table widget with data from the database
            self.SecurityLogs_table.setRowCount(0)
            for row in rows:
                row_index = self.SecurityLogs_table.rowCount()
                self.SecurityLogs_table.insertRow(row_index)
                for col_index, value in enumerate(row):
                    item = QtWidgets.QTableWidgetItem(str(value))
                    self.SecurityLogs_table.setItem(row_index, col_index, item)

            conn.close()
            
        def load_allReg_data(self):
            self.load_data_from_database_NetworkLists()
            self.load_data_from_database_NetworkInterfaces()
            self.load_data_from_database_ComputerName()
            self.load_data_from_database_Timezone()
            self.load_data_from_database_LastUpdate()
            self.load_data_from_database_LastUpdate_subkeys()
            self.load_data_from_database_shutdowninfo()
            self.load_data_from_database_MachineRune()
            self.load_data_from_database_MachineRuneOnce()
            self.load_data_from_database_UserRun()
            self.load_data_from_database_UserRunOnce()
        
        def load_files_activity(self):
            self.load_data_from_database_search_explorer_bar()
            self.load_data_from_database_RecentDocs()
            self.load_data_from_database_TypedPathes()
            self.load_data_from_database_OpenSaveMRU()
            self.load_data_from_database_LastSaveMRU()
            self.load_data_from_database_BAM()
            self.load_data_from_database_DAM()
        
        def load_all_logs(self):
            self.load_data_from_SystemLogs()
            self.load_data_from_SecurityLogs()
            self.load_data_from_appsLogs()

    # ============================================================================
    
    def load_data_from_database_NetworkLists(self):
        """Load Network Lists data from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Network_list")
            rows = cursor.fetchall()
            if hasattr(self, 'NetworkLists_table'):
                self.NetworkLists_table.setRowCount(0)
                for row in rows:
                    row_index = self.NetworkLists_table.rowCount()
                    self.NetworkLists_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.NetworkLists_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[NetworkLists] Error loading data: {str(e)}")
    
    def load_data_from_database_ComputerName(self):
        """Load Computer Name data from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM computer_Name")
            rows = cursor.fetchall()
            if hasattr(self, 'computerName_table'):
                self.computerName_table.setRowCount(0)
                for row in rows:
                    row_index = self.computerName_table.rowCount()
                    self.computerName_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.computerName_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[ComputerName] Error loading data: {str(e)}")
    
    def load_data_from_database_Timezone(self):
        """Load Timezone data from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM time_zone")
            rows = cursor.fetchall()
            if hasattr(self, 'TimeZone_table'):
                self.TimeZone_table.setRowCount(0)
                for row in rows:
                    row_index = self.TimeZone_table.rowCount()
                    self.TimeZone_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.TimeZone_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[Timezone] Error loading data: {str(e)}")
    
    def load_data_from_database_NetworkInterfaces(self):
        """Load Network Interfaces data from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM network_interfaces")
            rows = cursor.fetchall()
            if hasattr(self, 'NetworkInterface_table'):
                self.NetworkInterface_table.setRowCount(0)
                for row in rows:
                    row_index = self.NetworkInterface_table.rowCount()
                    self.NetworkInterface_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.NetworkInterface_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[NetworkInterfaces] Error loading data: {str(e)}")
    
    def load_data_from_database_MachineRune(self):
        """Load Machine Run data from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM machine_run")
            rows = cursor.fetchall()
            if hasattr(self, 'MachineRun_table'):
                self.MachineRun_table.setRowCount(0)
                for row in rows:
                    row_index = self.MachineRun_table.rowCount()
                    self.MachineRun_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.MachineRun_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[MachineRun] Error loading data: {str(e)}")
    
    def load_data_from_database_MachineRuneOnce(self):
        """Load Machine Run Once data from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM machine_run_once")
            rows = cursor.fetchall()
            if hasattr(self, 'MachineRunOnce_tabel'):  # Note: keeping original typo for compatibility
                self.MachineRunOnce_tabel.setRowCount(0)
                for row in rows:
                    row_index = self.MachineRunOnce_tabel.rowCount()
                    self.MachineRunOnce_tabel.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.MachineRunOnce_tabel.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[MachineRunOnce] Error loading data: {str(e)}")
    
    def load_data_from_database_UserRun(self):
        """Load User Run data from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM user_run")
            rows = cursor.fetchall()
            if hasattr(self, 'UserRun_table'):
                self.UserRun_table.setRowCount(0)
                for row in rows:
                    row_index = self.UserRun_table.rowCount()
                    self.UserRun_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.UserRun_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[UserRun] Error loading data: {str(e)}")
    
    def load_data_from_database_UserRunOnce(self):
        """Load User Run Once data from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM user_run_once")
            rows = cursor.fetchall()
            if hasattr(self, 'UserRunOnce_table'):
                self.UserRunOnce_table.setRowCount(0)
                for row in rows:
                    row_index = self.UserRunOnce_table.rowCount()
                    self.UserRunOnce_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.UserRunOnce_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[UserRunOnce] Error loading data: {str(e)}")
    
    def load_data_from_database_LastUpdate(self):
        """Load Windows Last Update data from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Windows_lastupdate")
            rows = cursor.fetchall()
            if hasattr(self, 'LastUpdate_table'):
                self.LastUpdate_table.setRowCount(0)
                for row in rows:
                    row_index = self.LastUpdate_table.rowCount()
                    self.LastUpdate_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.LastUpdate_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[LastUpdate] Error loading data: {str(e)}")
    
    def load_data_from_database_LastUpdate_subkeys(self):
        """Load Windows Last Update subkey info from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Windows_lastupdate")
            rows = cursor.fetchall()
            if hasattr(self, 'LastUpdateInfo_table'):
                self.LastUpdateInfo_table.setRowCount(0)
                for row in rows:
                    row_index = self.LastUpdateInfo_table.rowCount()
                    self.LastUpdateInfo_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.LastUpdateInfo_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[LastUpdateSubkeys] Error loading data: {str(e)}")
    
    def load_data_from_database_shutdowninfo(self):
        """Load Shutdown info from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Windows_lastupdate")  # Note: using same table as original
            rows = cursor.fetchall()
            if hasattr(self, 'ShutDown_table'):
                self.ShutDown_table.setRowCount(0)
                for row in rows:
                    row_index = self.ShutDown_table.rowCount()
                    self.ShutDown_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.ShutDown_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[ShutdownInfo] Error loading data: {str(e)}")
    
    def load_data_from_database_RecentDocs(self):
        """Load Recent Documents data from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM RecentDocs")
            rows = cursor.fetchall()
            if hasattr(self, 'RecentDocs_table'):
                self.RecentDocs_table.setRowCount(0)
                for row in rows:
                    row_index = self.RecentDocs_table.rowCount()
                    self.RecentDocs_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.RecentDocs_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[RecentDocs] Error loading data: {str(e)}")
    
    def load_data_from_database_search_explorer_bar(self):
        """Load Search Explorer Bar data from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM Search_Explorer_bar")
            rows = cursor.fetchall()
            if hasattr(self, 'SearchViaExplorer_table'):
                self.SearchViaExplorer_table.setRowCount(0)
                for row in rows:
                    row_index = self.SearchViaExplorer_table.rowCount()
                    self.SearchViaExplorer_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.SearchViaExplorer_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[SearchExplorerBar] Error loading data: {str(e)}")
    
    def load_data_from_database_OpenSaveMRU(self):
        """Load Open Save MRU data from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM OpenSaveMRU")
            rows = cursor.fetchall()
            if hasattr(self, 'OpenSaveMRU_table'):
                self.OpenSaveMRU_table.setRowCount(0)
                for row in rows:
                    row_index = self.OpenSaveMRU_table.rowCount()
                    self.OpenSaveMRU_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.OpenSaveMRU_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[OpenSaveMRU] Error loading data: {str(e)}")
    
    def load_data_from_database_LastSaveMRU(self):
        """Load Last Save MRU data from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM lastSaveMRU")
            rows = cursor.fetchall()
            if hasattr(self, 'LastSaveMRU_table'):
                self.LastSaveMRU_table.setRowCount(0)
                for row in rows:
                    row_index = self.LastSaveMRU_table.rowCount()
                    self.LastSaveMRU_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.LastSaveMRU_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[LastSaveMRU] Error loading data: {str(e)}")
    
    def load_data_from_database_TypedPathes(self):
        """Load Typed Paths data from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM TypedPaths")
            rows = cursor.fetchall()
            if hasattr(self, 'TypedPath_table'):
                self.TypedPath_table.setRowCount(0)
                for row in rows:
                    row_index = self.TypedPath_table.rowCount()
                    self.TypedPath_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.TypedPath_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[TypedPaths] Error loading data: {str(e)}")
    
    def load_data_from_database_BAM(self):
        """Load BAM (Background Activity Moderator) data from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM BAM")
            rows = cursor.fetchall()
            if hasattr(self, 'Bam_table'):
                self.Bam_table.setRowCount(0)
                for row in rows:
                    row_index = self.Bam_table.rowCount()
                    self.Bam_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.Bam_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[BAM] Error loading data: {str(e)}")
    
    def load_data_from_database_DAM(self):
        """Load DAM (Desktop Activity Moderator) data from registry database"""
        try:
            conn = sqlite3.connect('registry_data.db')
            cursor = conn.cursor()
            cursor.execute("SELECT * FROM DAM")
            rows = cursor.fetchall()
            if hasattr(self, 'Dam_table'):
                self.Dam_table.setRowCount(0)
                for row in rows:
                    row_index = self.Dam_table.rowCount()
                    self.Dam_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.Dam_table.setItem(row_index, col_index, item)
            conn.close()
        except Exception as e:
            print(f"[DAM] Error loading data: {str(e)}")
    
    def load_data_from_database_lnkAJL(self):
        """Load LNK and Automatic Jump List data into the LNK table"""
        try:
            # Use the proper database path based on current case
            db_path = self.get_lnk_db_path()
            
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[LNK/AJL] Database not found at: {db_path}")
                print(f"[LNK/AJL] Please run LNK analysis first to create the database")
                return
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if JLCE table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='JLCE'")
            if not cursor.fetchone():
                print(f"[LNK/AJL] JLCE table not found in database: {db_path}")
                conn.close()
                return
                
            cursor.execute("SELECT * FROM JLCE")
            rows = cursor.fetchall()
            if hasattr(self, 'LNK_table'):
                self.LNK_table.setRowCount(0)
                for row in rows:
                    row_index = self.LNK_table.rowCount()
                    self.LNK_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.LNK_table.setItem(row_index, col_index, item)
                print(f"[LNK/AJL] Successfully loaded {len(rows)} records from {db_path}")
            conn.close()
        except Exception as e:
            print(f"[LNK/AJL] Error loading data: {str(e)}")
    
    def load_data_from_database_CJL(self):
        """Load Custom Jump List data into the CJL table"""
        try:
            # Use the proper database path based on current case
            db_path = self.get_lnk_db_path()
            
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[CJL] Database not found at: {db_path}")
                print(f"[CJL] Please run LNK analysis first to create the database")
                return
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if Custom_JLCE table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='Custom_JLCE'")
            if not cursor.fetchone():
                print(f"[CJL] Custom_JLCE table not found in database: {db_path}")
                conn.close()
                return
                
            cursor.execute("SELECT * FROM Custom_JLCE")
            rows = cursor.fetchall()
            if hasattr(self, 'Clj_table'):
                self.Clj_table.setRowCount(0)
                for row in rows:
                    row_index = self.Clj_table.rowCount()
                    self.Clj_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.Clj_table.setItem(row_index, col_index, item)
                print(f"[CJL] Successfully loaded {len(rows)} records from {db_path}")
            conn.close()
        except Exception as e:
            print(f"[CJL] Error loading data: {str(e)}")
    
    def load_data_from_SystemLogs(self):
        """Load System Logs data from the log database"""
        try:
            # Use the proper database path based on current case
            db_path = self.get_log_db_path()
            
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[SystemLogs] Database not found at: {db_path}")
                print(f"[SystemLogs] Please run logs analysis first to create the database")
                return
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if SystemLogs table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='SystemLogs'")
            if not cursor.fetchone():
                print(f"[SystemLogs] SystemLogs table not found in database: {db_path}")
                conn.close()
                return
                
            cursor.execute("SELECT * FROM SystemLogs")
            rows = cursor.fetchall()
            # Use the correct table name from the UI
            if hasattr(self, 'tableWidget_22'):
                self.tableWidget_22.setRowCount(0)
                for row in rows:
                    row_index = self.tableWidget_22.rowCount()
                    self.tableWidget_22.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.tableWidget_22.setItem(row_index, col_index, item)
                print(f"[SystemLogs] Successfully loaded {len(rows)} records from {db_path}")
            conn.close()
        except Exception as e:
            print(f"[SystemLogs] Error loading data: {str(e)}")
    
    def load_data_from_appsLogs(self):
        """Load Application Logs data from the log database"""
        try:
            # Use the proper database path based on current case
            db_path = self.get_log_db_path()
            
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[AppLogs] Database not found at: {db_path}")
                print(f"[AppLogs] Please run logs analysis first to create the database")
                return
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if ApplicationLogs table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='ApplicationLogs'")
            if not cursor.fetchone():
                print(f"[AppLogs] ApplicationLogs table not found in database: {db_path}")
                conn.close()
                return
                
            cursor.execute("SELECT * FROM ApplicationLogs")
            rows = cursor.fetchall()
            if hasattr(self, 'AppLogs_table'):
                self.AppLogs_table.setRowCount(0)
                for row in rows:
                    row_index = self.AppLogs_table.rowCount()
                    self.AppLogs_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.AppLogs_table.setItem(row_index, col_index, item)
                print(f"[AppLogs] Successfully loaded {len(rows)} records from {db_path}")
            conn.close()
        except Exception as e:
            print(f"[AppLogs] Error loading data: {str(e)}")
    
    def load_data_from_SecurityLogs(self):
        """Load Security Logs data from the log database"""
        try:
            # Use the proper database path based on current case
            db_path = self.get_log_db_path()
            
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[SecurityLogs] Database not found at: {db_path}")
                print(f"[SecurityLogs] Please run logs analysis first to create the database")
                return
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if SecurityLogs table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='SecurityLogs'")
            if not cursor.fetchone():
                print(f"[SecurityLogs] SecurityLogs table not found in database: {db_path}")
                conn.close()
                return
                
            cursor.execute("SELECT * FROM SecurityLogs")
            rows = cursor.fetchall()
            if hasattr(self, 'SecurityLogs_table'):
                self.SecurityLogs_table.setRowCount(0)
                for row in rows:
                    row_index = self.SecurityLogs_table.rowCount()
                    self.SecurityLogs_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.SecurityLogs_table.setItem(row_index, col_index, item)
                print(f"[SecurityLogs] Successfully loaded {len(rows)} records from {db_path}")
            conn.close()
        except Exception as e:
            print(f"[SecurityLogs] Error loading data: {str(e)}")
    
    def load_shimcache_data(self):
        """Load ShimCache data from the shimcache database"""
        try:
            # Get the database path from case configuration
            if not hasattr(self, 'case_paths') or not self.case_paths:
                print("[ShimCache] No active case found")
                return
                
            db_path = self.case_paths.get('databases', {}).get('shimcache')
            if not db_path:
                print("[ShimCache] Database path not found in case configuration")
                return
                
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[ShimCache] Database not found at: {db_path}")
                print(f"[ShimCache] Please run ShimCache analysis first to create the database")
                return
            
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if ShimCache table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='ShimCache'")
            if not cursor.fetchone():
                print(f"[ShimCache] ShimCache table not found in database: {db_path}")
                conn.close()
                return
                
            cursor.execute("SELECT * FROM ShimCache")
            rows = cursor.fetchall()
            if hasattr(self, 'ShimCache_table'):
                self.ShimCache_table.setRowCount(0)
                for row in rows:
                    row_index = self.ShimCache_table.rowCount()
                    self.ShimCache_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value))
                        self.ShimCache_table.setItem(row_index, col_index, item)
                print(f"[ShimCache] Successfully loaded {len(rows)} records from {db_path}")
            conn.close()
        except Exception as e:
            print(f"[ShimCache] Error loading data: {str(e)}")
    
    # ============================================================================
    # ENHANCED GROUPED DATA LOADING METHODS
    # ============================================================================
    
    def load_enhanced_allReg_data(self):
        """Load all registry data using enhanced methods with cyberpunk loading"""
        def run_registry_loading():
            print("[Registry] Loading Network Lists...")
            self.load_data_from_database_NetworkLists()
            print("[Registry] Loading Network Interfaces...")
            self.load_data_from_database_NetworkInterfaces()
            print("[Registry] Loading Computer Name...")
            self.load_data_from_database_ComputerName()
            print("[Registry] Loading Timezone...")
            self.load_data_from_database_Timezone()
            print("[Registry] Loading Last Update...")
            self.load_data_from_database_LastUpdate()
            print("[Registry] Loading Last Update Subkeys...")
            self.load_data_from_database_LastUpdate_subkeys()
            print("[Registry] Loading Shutdown Info...")
            self.load_data_from_database_shutdowninfo()
            print("[Registry] Loading Machine Run...")
            self.load_data_from_database_MachineRune()
            print("[Registry] Loading Machine Run Once...")
            self.load_data_from_database_MachineRuneOnce()
            print("[Registry] Loading User Run...")
            self.load_data_from_database_UserRun()
            print("[Registry] Loading User Run Once...")
            self.load_data_from_database_UserRunOnce()
            print("[Registry] All registry data loaded successfully")
        
        # Use cyberpunk loading dialog
        self.show_loading_screen_with_function(
            "LOADING REGISTRY DATA",
            run_registry_loading
        )
    
    
    
    def setup_table_headers(self, table, column_count):
        """Helper function to setup table headers - reduces code duplication"""
        try:
            if not table:
                print("Error: Table widget is None")
                return
                
            # First clear existing headers
            table.setColumnCount(0)
            table.setColumnCount(column_count)
            table.setRowCount(0)
            
            # Configure header appearance
            header = table.horizontalHeader()
            if not header:
                print("Error: Could not get horizontal header")
                return
                
            # Default header color variant; can be overridden per-table later
            try:
                header.setObjectName("header_blue")
            except Exception:
                pass
            
            # Set default header items
            for i in range(column_count):
                item = QtWidgets.QTableWidgetItem()
                item.setTextAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)
                item.setFont(self.create_standard_font("Segoe UI", 9, True, False))
                table.setHorizontalHeaderItem(i, item)
            
            # Apply header styles
            header.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)

            # Enhanced resizing configuration
            header.setDefaultSectionSize(250)
            header.setMinimumSectionSize(80)
            header.setSectionsClickable(True)
            header.setSortIndicatorShown(True)
            header.setSectionsMovable(True)
            header.setSectionResizeMode(QtWidgets.QHeaderView.Interactive)
            header.setStretchLastSection(False)  # Allow manual resizing of all columns
            
            # Force style update with additional header-specific styling
            header.setAttribute(QtCore.Qt.WA_StyledBackground, True)
            header.style().unpolish(header)
            header.style().polish(header)
            
            # Safely update viewport
            viewport = header.viewport()
            if viewport:
                viewport.update()
            else:
                print("Warning: Header viewport not available")
                
        except Exception as e:
            print(f"Error setting up table: {str(e)}")
            return
    
    def load_registry_data_to_table(self, table_name, table_widget, db_path='registry_data_live.db'):
        """Generic helper function to load data from database to table widget with proper validation"""
        conn = None
        try:
            # Validate database path
            if not os.path.exists(db_path):
                print(f"[Database Error] Database file not found: {db_path}")
                return False
            
            # Disable updates during loading
            was_updates_enabled = table_widget.updatesEnabled()
            table_widget.setUpdatesEnabled(False)
            
            # Clear existing data
            table_widget.setRowCount(0)
            
            # Connect to database
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Schema validation - check if table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?;", (table_name,))
            if not cursor.fetchone():
                print(f"[Database Error] Table '{table_name}' does not exist in database: {db_path}")
                return False
            
            # Get table schema for validation
            cursor.execute(f"PRAGMA table_info({table_name});")
            columns_info = cursor.fetchall()
            if not columns_info:
                print(f"[Database Error] Unable to retrieve schema for table '{table_name}'")
                return False
            
            # Extract column names
            columns = [column[1] for column in columns_info]
            
            # Fetch data
            cursor.execute(f"SELECT * FROM {table_name}")
            data = cursor.fetchall()
            
            if not data:
                print(f"[Database Info] No data found in table '{table_name}'")
                table_widget.setUpdatesEnabled(was_updates_enabled)
                return True  # Empty table is still a success
                
            # Validate data consistency
            if data and len(data[0]) != len(columns):
                print(f"[Database Error] Data column count mismatch in table '{table_name}'")
                return False
            
            # Set column count and headers
            if table_widget.columnCount() != len(columns):
                table_widget.setColumnCount(len(columns))
                table_widget.setHorizontalHeaderLabels(columns)
            
            # Populate data in batches for better performance
            batch_size = 1000
            table_widget.setRowCount(len(data))
            
            for i in range(0, len(data), batch_size):
                batch = data[i:i + batch_size]
                for row_index, row_data in enumerate(batch, start=i):
                    for col_index, cell_data in enumerate(row_data):
                        item = QtWidgets.QTableWidgetItem(str(cell_data) if cell_data is not None else "")
                        item.setFlags(item.flags() & ~Qt.ItemIsEditable)  # Make cells read-only
                        table_widget.setItem(row_index, col_index, item)
                
                # Process events periodically to keep UI responsive
                if i % batch_size == 0:
                    QtWidgets.QApplication.processEvents()
            
            # Resize columns to fit content
            table_widget.resizeColumnsToContents()
            
            # Apply styles after data is loaded
            table_widget.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
            table_widget.horizontalHeader().setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
            
            # Force style update
            table_widget.style().unpolish(table_widget)
            table_widget.style().polish(table_widget)
            
            # Restore updates state
            table_widget.setUpdatesEnabled(was_updates_enabled)
            
            # Trigger a repaint
            table_widget.viewport().update()
            
            print(f"[Database Success] Loaded {len(data)} records from '{table_name}'")
            return True
            
        except sqlite3.DatabaseError as e:
            print(f"[Database Error] SQLite error loading '{table_name}': {str(e)}")
            return False
        except Exception as e:
            print(f"[Database Error] Unexpected error loading '{table_name}': {str(e)}")
            return False
        finally:
            # Ensure connection is always closed
            if conn:
                try:
                    conn.close()
                except:
                    pass
            
            # Restore updates state even if there was an error
            if 'was_updates_enabled' in locals():
                table_widget.setUpdatesEnabled(was_updates_enabled)
    
    def show_database_error(self, title, db_path, error_msg=None):
        """Helper function to show database error messages - reduces code duplication"""
        if error_msg:
            message = f"Failed to load {title.lower()}: {error_msg}"
            print(f"[{title} Error] {message}")
        else:
            message = f"Database file not found: {db_path}"
            print(f"[{title} Error] {message}")
        
        self.show_error_message(title, message, "warning")
    
    def load_data_with_error_handling(self, db_path, table_name, table_widget, title):
        """Generic helper for loading data with consistent error handling"""
        try:
            print(f"[{title}] Loading from database: {db_path}")
            if not os.path.exists(db_path):
                self.show_database_error(title, db_path)
                return
            
            self.load_registry_data_to_table(table_name, table_widget, db_path)
            print(f"[{title}] Successfully loaded records")
        except Exception as e:
            self.show_database_error(title, db_path, str(e))
    
    def get_log_db_path(self):
        """Helper function to get Log_Claw.db path - reduces code duplication"""
        db_path = 'Log_Claw.db'
        if hasattr(self, 'case_paths') and self.case_paths:
            artifacts_dir = self.case_paths.get('artifacts_dir')
            if artifacts_dir and os.path.exists(artifacts_dir):
                db_path = os.path.join(artifacts_dir, 'Log_Claw.db')
        return db_path
    
    def get_registry_db_path(self):
        """Helper function to get registry_data.db path based on current case"""
        db_path = 'registry_data.db'
        if hasattr(self, 'case_paths') and self.case_paths:
            artifacts_dir = self.case_paths.get('artifacts_dir')
            if artifacts_dir and os.path.exists(artifacts_dir):
                db_path = os.path.join(artifacts_dir, 'registry_data.db')
        return db_path
    
    def get_lnk_db_path(self):
        """Helper function to get LnkDB.db path - reduces code duplication"""
        db_path = 'LnkDB.db'
        if hasattr(self, 'case_paths') and self.case_paths:
            artifacts_dir = self.case_paths.get('artifacts_dir')
            if artifacts_dir and os.path.exists(artifacts_dir):
                db_path = os.path.join(artifacts_dir, 'LnkDB.db')
        return db_path
        
    def get_shimcache_db_path(self):
        """Helper function to get shimcache.db path based on current case"""
        db_path = 'shimcache.db'
        if hasattr(self, 'case_paths') and self.case_paths:
            artifacts_dir = self.case_paths.get('artifacts_dir')
            if artifacts_dir and os.path.exists(artifacts_dir):
                db_path = os.path.join(artifacts_dir, 'shimcache.db')
        return db_path
        
    def load_shimcache_data(self):
        """Load ShimCache data from database to table"""
        try:
            # Get the database path based on current case
            db_path = self.get_shimcache_db_path()
            
            # Check if database exists
            if not os.path.exists(db_path):
                print(f"[ShimCache] Database not found at: {db_path}")
                print(f"[ShimCache] Please run ShimCache analysis first to create the database")
                return
            
            # Connect to database
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            
            # Check if shimcache_entries table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='shimcache_entries'")
            if not cursor.fetchone():
                print(f"[ShimCache] shimcache_entries table not found in database: {db_path}")
                conn.close()
                return
                
            # Query to get all ShimCache entries
            cursor.execute("""SELECT filename, path, last_modified, last_modified_readable, parsed_timestamp 
                          FROM shimcache_entries ORDER BY last_modified DESC""")
            rows = cursor.fetchall()
            
            # Load data into the main ShimCache table
            if hasattr(self, 'ShimCache_main_table'):
                # Disable updates during loading for performance
                was_updates_enabled = self.ShimCache_main_table.updatesEnabled()
                self.ShimCache_main_table.setUpdatesEnabled(False)
                
                # Set column headers if not already set
                if self.ShimCache_main_table.columnCount() != 5:
                    self.ShimCache_main_table.setColumnCount(5)
                    headers = ["Filename", "Path", "Last Modified (Epoch)", "Last Modified", "Parsed Timestamp"]
                    self.ShimCache_main_table.setHorizontalHeaderLabels(headers)
                
                # Clear existing rows
                self.ShimCache_main_table.setRowCount(0)
                
                # Add data in batches for better performance
                batch_size = 100
                for i, row in enumerate(rows):
                    row_index = self.ShimCache_main_table.rowCount()
                    self.ShimCache_main_table.insertRow(row_index)
                    for col_index, value in enumerate(row):
                        item = QtWidgets.QTableWidgetItem(str(value) if value is not None else "")
                        item.setFlags(item.flags() & ~Qt.ItemIsEditable)  # Make cells read-only
                        self.ShimCache_main_table.setItem(row_index, col_index, item)
                    
                    # Process events periodically to keep UI responsive
                    if (i + 1) % batch_size == 0:
                        QtWidgets.QApplication.processEvents()
                
                # Re-enable updates and resize columns to content
                self.ShimCache_main_table.setUpdatesEnabled(was_updates_enabled)
                self.ShimCache_main_table.resizeColumnsToContents()
                
                print(f"[ShimCache] Loaded {len(rows)} records into main ShimCache table")
            
            conn.close()
        except Exception as e:
            print(f"[ShimCache] Error loading data: {str(e)}")
            import traceback
            traceback.print_exc()
    
    def create_crow_eye_dialog(self, title, style_sheet=None):
        """Helper function to create standardized Crow Eye dialogs - reduces code duplication"""
        dialog = QtWidgets.QDialog(self.main_window)
        dialog.setWindowTitle(f"Crow Eye - {title}")
        dialog.setWindowIcon(QtGui.QIcon(":/Icons/CrowEye.ico"))
        dialog.setModal(True)
        
        if style_sheet:
            dialog.setStyleSheet(style_sheet)
        
        return dialog
    
    def add_logo_section(self, layout, logo_size=(100, 100)):
        """Helper function to add logo section to dialogs - reduces code duplication"""
        # Logo section
        logo_frame = QtWidgets.QFrame()
        logo_frame.setObjectName("logo_frame")
        logo_layout = QtWidgets.QHBoxLayout(logo_frame)
        logo_layout.setAlignment(Qt.AlignCenter)
        
        # Add Crow Eye logo
        logo_label = QtWidgets.QLabel()
        logo_label.setAlignment(Qt.AlignCenter)
        
        # Load logo using helper function
        logo_pixmap = self.load_logo_pixmap(logo_size)
        logo_pixmap = logo_pixmap.scaled(logo_size[0], logo_size[1], Qt.KeepAspectRatio, Qt.SmoothTransformation)
        logo_label.setPixmap(logo_pixmap)
        logo_layout.addWidget(logo_label)
        
        layout.addWidget(logo_frame)
        return logo_frame
    
    def create_standard_font(self, family="MS Shell Dlg 2", size=10, bold=True, italic=False):
        """Helper function to create standardized fonts - reduces code duplication"""
        font = QtGui.QFont()
        font.setFamily(family)
        font.setPointSize(size)
        font.setBold(bold)
        font.setItalic(italic)
        if bold:
            font.setWeight(75)
        return font
    
    def create_rockwell_font(self, size=8, bold=False):
        """Helper function to create Rockwell Extra Bold fonts - reduces code duplication"""
        font = QtGui.QFont()
        font.setFamily("Rockwell Extra Bold")
        font.setPointSize(size)
        font.setBold(bold)
        return font
    
    def setup_sidebar_button(self, button, checkable=True, checked=True, default=False):
        """Helper function to setup sidebar buttons with consistent configuration - reduces code duplication"""
        button.setStyleSheet(CrowEyeStyles.SIDEBAR_BUTTON)
        button.setCheckable(checkable)
        button.setChecked(checked)
        if default:
            button.setDefault(True)
        return button
    
    def setup_parse_button(self, button, checkable=True, checked=False, default=False, style='green'):
        """Helper function to setup parse buttons (LNK, Logs, offline analysis) with consistent styling
        
        Args:
            button: The button widget to style
            checkable: Whether the button is checkable
            checked: Initial checked state
            default: Whether this is the default button
            style: Button style ('green' or 'red')
        """
        # Apply appropriate style based on the style parameter
        if style.lower() == 'red':
            button.setStyleSheet(CrowEyeStyles.RED_BUTTON)
        else:  # Default to green
            button.setStyleSheet(CrowEyeStyles.GREEN_BUTTON)
            
        button.setCheckable(checkable)
        button.setChecked(checked)
        button.setDefault(default)
        button.setCursor(QtCore.Qt.PointingHandCursor)
        
        # Set font
        font = QtGui.QFont()
        font.setFamily("MS Shell Dlg 2")
        font.setPointSize(9)
        font.setBold(True)
        button.setFont(font)
        
        # Set size policy
        size_policy = QtWidgets.QSizePolicy(
            QtWidgets.QSizePolicy.Preferred,
            QtWidgets.QSizePolicy.Preferred
        )
        size_policy.setHorizontalStretch(0)
        size_policy.setVerticalStretch(0)
        size_policy.setHeightForWidth(button.sizePolicy().hasHeightForWidth())
        button.setSizePolicy(size_policy)
        button.setMinimumSize(QtCore.QSize(100, 30))
        button.setMaximumSize(QtCore.QSize(200, 16777215))
        
        # Set focus policy
        button.setFocusPolicy(QtCore.Qt.StrongFocus)
        
        # Set tooltip
        button.setToolTip("Click to parse data")
        
        # Force style update
        button.style().unpolish(button)
        button.style().polish(button)
        button.update()
        
        return button
    
    def refresh_all_tables(self):
        """Refresh all tables in the application with current styles"""
        try:
            # Find all table widgets
            tables = [getattr(self, name) for name in dir(self) 
                     if isinstance(getattr(self, name), QtWidgets.QTableWidget)]
            
            # Process each table with a small delay between them
            for i, table in enumerate(tables):
                QtCore.QTimer.singleShot(i * 100, lambda t=table: self._refresh_table(t))
                
        except Exception as e:
            print(f"Error in refresh_all_tables: {str(e)}")
    
    def _refresh_table(self, table):
        """Internal method to refresh a single table's styles"""
        if not table or not table.isVisible():
            return
            
        # Store current state
        was_updates_enabled = table.updatesEnabled()
        h_scroll = table.horizontalScrollBar().value()
        v_scroll = table.verticalScrollBar().value()
        
        # Disable updates during refresh
        table.setUpdatesEnabled(False)
        
        # Define restore_scroll function before try block
        def restore_scroll():
            try:
                if not table:
                    return
                    
                # Update geometry first
                table.updateGeometry()
                
                # Restore scroll positions
                if h_scroll < table.horizontalScrollBar().maximum():
                    table.horizontalScrollBar().setValue(h_scroll)
                if v_scroll < table.verticalScrollBar().maximum():
                    table.verticalScrollBar().setValue(v_scroll)
                
                # Final style refresh
                table.style().unpolish(table)
                table.style().polish(table)
                
                # Update viewport
                viewport = table.viewport()
                if viewport:
                    viewport.update()
                    
                # Force a complete repaint
                table.update()
            except Exception as e:
                print(f"Error in restore_scroll: {str(e)}")
            finally:
                table.setUpdatesEnabled(was_updates_enabled)
        
        try:
            # Clear and reapply styles
            table.setStyleSheet('')
            
            # Apply base table style using unified style
            table.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
            
            # Apply styles to header
            header = table.horizontalHeader()
            if header:
                header.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
                header.setDefaultAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            
            # Apply styles to viewport
            viewport = table.viewport()
            if viewport:
                viewport.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
            
            # Force style update
            table.style().unpolish(table)
            table.style().polish(table)
            
            # Update all items' styles
            for row in range(table.rowCount()):
                for col in range(table.columnCount()):
                    item = table.item(row, col)
                    if item:
                        item.setFlags(item.flags() & ~Qt.ItemIsEditable)
            
            # Ensure proper rendering
            table.update()
            # Get viewport after table is set up
            viewport = table.viewport()
            if viewport:
                viewport.update()
            
            # Schedule the scroll restoration
            QtCore.QTimer.singleShot(50, restore_scroll)
            
        except Exception as e:
            print(f"Error refreshing table: {str(e)}")
            table.setUpdatesEnabled(was_updates_enabled)
    
    def apply_table_styles(self, table):
        """Apply styles to the table after it has been populated"""
        if not table:
            return
            
        try:
            # Store current update state
            was_updates_enabled = table.updatesEnabled()
            table.setUpdatesEnabled(False)
            
            # Apply base styles using the new unified style
            table.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
            
            # Update header styles
            header = table.horizontalHeader()
            if header:
                header.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
                header.setDefaultAlignment(Qt.AlignLeft | Qt.AlignVCenter)
                header.update()
            
            # Update viewport styles
            viewport = table.viewport()
            if viewport:
                viewport.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
                viewport.update()
            
            # Force style updates
            table.style().unpolish(table)
            table.style().polish(table)
            
            # Update all items' styles and make them read-only
            for row in range(table.rowCount()):
                for col in range(table.columnCount()):
                    item = table.item(row, col)
                    if item:
                        item.setFlags((item.flags() & ~Qt.ItemIsEditable) | Qt.ItemIsEnabled)
            
            # Ensure proper rendering
            table.update()
            if viewport:
                viewport.update()
                
        except Exception as e:
            print(f"Error applying table styles: {str(e)}")
            
        finally:
            # Always restore update state
            table.setUpdatesEnabled(was_updates_enabled)

    # --- Sidebar toggle animation ---
    def toggle_sidebar(self, checked=False):
        try:
            if not hasattr(self, "_sidebar_anim"):
                self._sidebar_anim = QtCore.QPropertyAnimation(self.side_fram, b"maximumWidth")
                self._sidebar_anim.setDuration(260)
                self._sidebar_anim.setEasingCurve(QtCore.QEasingCurve.InOutCubic)
                # After animation completes, normalize min width to the target to avoid re-collapse by layout
                def _on_sidebar_anim_finished():
                    try:
                        target = getattr(self, "_sidebar_target", None)
                        if target is not None:
                            if target > 0:
                                self.side_fram.setMinimumWidth(target)
                                self.side_fram.setMaximumWidth(target)
                                self.side_fram.setVisible(True)
                            else:
                                # Fully collapsed: set max to 0 and hide
                                self.side_fram.setMinimumWidth(0)
                                self.side_fram.setMaximumWidth(0)
                                self.side_fram.setVisible(False)
                    except Exception:
                        pass
                self._sidebar_anim.finished.connect(_on_sidebar_anim_finished)
                # During animation, keep min/max synced to current value so it can reach 0 exactly
                def _on_sidebar_anim_value_changed(value):
                    try:
                        w = int(value)
                        self.side_fram.setMinimumWidth(w)
                        self.side_fram.setMaximumWidth(w)
                    except Exception:
                        pass
                try:
                    self._sidebar_anim.valueChanged.connect(_on_sidebar_anim_value_changed)
                except Exception:
                    pass

            # Define collapsed/expanded sizes (fully collapse to 0)
            collapsed = 0
            # Determine full width based on sizeHint if available
            if not hasattr(self, "_sidebar_full_width") or not self._sidebar_full_width:
                hint = max(240, self.side_fram.sizeHint().width())
                self._sidebar_full_width = hint
            expanded = self._sidebar_full_width

            # Ensure current constraints
            self.side_fram.setMinimumWidth(0)
            # Do not clamp max to current width; allow full expansion target
            # We'll animate the maximumWidth property between collapsed and expanded

            current = self.side_fram.maximumWidth()
            if not current:
                current = self.side_fram.width()
            end = expanded if (checked or not hasattr(self, "_sidebar_expanded") or not self._sidebar_expanded) else collapsed

            self._sidebar_anim.stop()
            # Ensure frame is visible before expanding, so animation is seen
            if end > 0:
                self.side_fram.setVisible(True)
            self._sidebar_anim.setStartValue(current)
            self._sidebar_anim.setEndValue(end)
            self._sidebar_target = end
            self._sidebar_anim.start()

            # Track state
            self._sidebar_expanded = (end == expanded)
        except Exception as e:
            print(f"Sidebar toggle error: {e}")
    
    def setup_standard_tab_widget(self, tab_widget, style_sheet=None, tab_button_style=None):
        """Helper function to setup tab widgets with consistent configuration"""
        try:
            if not tab_widget:
                return
                
            # Standard tab widget configuration
            tab_widget.setTabPosition(QtWidgets.QTabWidget.North)
            tab_widget.setTabShape(QtWidgets.QTabWidget.Rounded)
            tab_widget.setElideMode(Qt.ElideNone)
            tab_widget.setTabsClosable(False)
            tab_widget.setMovable(True)
            tab_widget.setTabBarAutoHide(False)  # Keep tabs always visible for consistency
            
            # Combine both style_sheet and tab_button_style if both are provided
            combined_style = ""
            if style_sheet:
                combined_style += style_sheet
            if tab_button_style:
                if combined_style:
                    combined_style += "\n" + tab_button_style
                else:
                    combined_style = tab_button_style
                    
            if combined_style:
                tab_widget.setStyleSheet(combined_style)
                
            # Make tabs expand to utilize available width
            try:
                tab_widget.tabBar().setExpanding(True)
            except Exception:
                pass
                
            # Force style update
            tab_widget.style().unpolish(tab_widget)
            tab_widget.style().polish(tab_widget)
            tab_widget.update()
                
        except Exception as e:
            print(f"Tab widget setup error: {e}")
    
    def setup_standard_tab_background(self, tab_widget):
        """Apply consistent background styling to all tab pages in a tab widget"""
        try:
            if not tab_widget:
                return
                
            for i in range(tab_widget.count()):
                tab_page = tab_widget.widget(i)
                if tab_page and not tab_page.styleSheet():
                    # Only apply if no custom styling is already set
                    tab_page.setStyleSheet(CrowEyeStyles.TAB_BACKGROUND)
                    
        except Exception as e:
            print(f"Tab background setup error: {e}")
    
    def apply_custom_tab_style(self, tab_widget, style_name="cyberpunk"):
        """Apply custom tab button styles to a tab widget"""
        try:
            if not tab_widget:
                return
                
            # Map style names to actual styles
            style_map = {
                "cyberpunk": CrowEyeStyles.CYBERPUNK_TAB_STYLE,
                "enhanced": CrowEyeStyles.TAB_BUTTON_STYLE,
                "main": CrowEyeStyles.MAIN_TAB_WIDGET,
                "sub": CrowEyeStyles.SUB_TAB_WIDGET
            }
            
            # Apply the selected style
            if style_name in style_map:
                tab_widget.setStyleSheet(style_map[style_name])
            else:
                # Default to cyberpunk style
                tab_widget.setStyleSheet(CrowEyeStyles.CYBERPUNK_TAB_STYLE)
                
        except Exception as e:
            print(f"Custom tab style application error: {e}")
    
    def setup_standard_table(self, table, column_count, auto_fill=True, default_section_size=300, min_section_size=None):
        """Helper function to setup tables with consistent configuration"""
        try:
            if not table:
                return
                
            # Disable updates during setup
            was_updates_enabled = table.updatesEnabled()
            table.setUpdatesEnabled(False)
            
            # Store current scroll positions
            h_scroll = table.horizontalScrollBar().value()
            v_scroll = table.verticalScrollBar().value()
            
            # Initialize viewport variable
            viewport = None
            
            # Clear existing items and reset
            table.clear()
            table.setRowCount(0)
            table.setColumnCount(0)
            
            # Set column count
            table.setColumnCount(column_count)
            
            # Enable sorting
            table.setSortingEnabled(True)
            
            # Enable alternating row colors
            table.setAlternatingRowColors(True)
            
            # Set selection behavior
            table.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
            table.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
            
            # Configure headers
            header = table.horizontalHeader()
            if header:
                header.setStretchLastSection(True)
                header.setDefaultAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)
                header.setSectionsClickable(True)
                header.setSortIndicatorShown(True)
                header.setHighlightSections(True)
                header.setAttribute(QtCore.Qt.WA_StyledBackground, True)
                
                # Apply style to header
                header_style = """
                    QHeaderView::section {
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                                stop:0 #1E293B, stop:1 #111827);
                        color: #E5E7EB;
                        padding: 12px 8px;
                        border: none;
                        border-right: 1px solid #334155;
                        border-bottom: 2px solid #334155;
                        font-weight: bold;
                        font-size: 13px;
                        text-transform: uppercase;
                        letter-spacing: 1px;
                    }
                    QHeaderView::section:hover {
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                                stop:0 #334155, stop:1 #1E293B);
                        color: #00FFFF;
                    }
                    QHeaderView::section:checked {
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                                stop:0 #0EA5E9, stop:1 #007ACC);
                        color: #FFFFFF;
                        border-bottom: 2px solid #00FFFF;
                    }
                """
    
                header.style().unpolish(header)
                header.style().polish(header)
                header.update()
            
            # Configure vertical header
            vheader = table.verticalHeader()
            if vheader:
                vheader.setVisible(True)
                vheader.setDefaultSectionSize(40)
                vheader.setMinimumSectionSize(30)
            
            # Apply table style
            table.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
            
            # Force style updates
            table.setAttribute(QtCore.Qt.WA_StyledBackground, True)
            table.style().unpolish(table)
            table.style().polish(table)
            
            # Apply auto-fill if needed
            if auto_fill:
                table.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
            else:
                table.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Interactive)
                if default_section_size:
                    table.horizontalHeader().setDefaultSectionSize(default_section_size)
                if min_section_size:
                    table.horizontalHeader().setMinimumSectionSize(min_section_size)
                    
                # Ensure table has reasonable minimum size
                table.setMinimumHeight(200)
                table.setMinimumWidth(400)
            
            # Ensure proper rendering
            table.update()
            if viewport:
                viewport.update()
            
            # Restore scroll positions after a short delay
            def restore_scroll():
                try:
                    if not table:
                        return
                        
                    # Update geometry first
                    table.updateGeometry()
                    
                    # Restore scroll positions if they're within valid range
                    if h_scroll < table.horizontalScrollBar().maximum():
                        table.horizontalScrollBar().setValue(h_scroll)
                    if v_scroll < table.verticalScrollBar().maximum():
                        table.verticalScrollBar().setValue(v_scroll)
                    
                    # Final style refresh
                    table.style().unpolish(table)
                    table.style().polish(table)
                    
                    # Update viewport
                    viewport = table.viewport()
                    if viewport:
                        viewport.update()
                    
                    # Force a complete repaint
                    table.update()
                except Exception as e:
                    print(f"Error in restore_scroll: {str(e)}")
                finally:
                    table.setUpdatesEnabled(was_updates_enabled)
            
            QtCore.QTimer.singleShot(50, restore_scroll)
            
        except Exception as e:
            print(f"Error setting up table: {str(e)}")
            if 'was_updates_enabled' in locals():
                table.setUpdatesEnabled(was_updates_enabled)
            return table
    
    def create_crow_eye_title_label(self, style_sheet=None):
        """Helper function to create standardized 'CROW EYE SYSTEM' title labels - reduces code duplication"""
        title_label = QtWidgets.QLabel("CROW EYE SYSTEM")
        if style_sheet:
            title_label.setStyleSheet(style_sheet)
        else:
            title_label.setStyleSheet(CrowEyeStyles.LOADING_TITLE)
        title_label.setAlignment(Qt.AlignCenter)
        return title_label
    
    def create_progress_bar(self, indeterminate=True, height=25):
        """Helper function to create standardized progress bars - reduces code duplication"""
        progress_bar = QtWidgets.QProgressBar()
        if indeterminate:
            progress_bar.setRange(0, 0)  # Indeterminate progress
        else:
            progress_bar.setRange(0, 100)
            progress_bar.setValue(0)
        progress_bar.setMinimumHeight(height)
        progress_bar.setMaximumHeight(height)
        return progress_bar
    
    def center_dialog_on_parent(self, dialog, parent=None):
        """Helper function to center dialogs on parent window - reduces code duplication"""
        if not parent:
            parent = self.main_window
        if parent:
            dialog.move(
                parent.frameGeometry().center() - dialog.frameGeometry().center()
            )
    
    def show_error_message(self, title, message, error_type="critical"):
        """Helper function to show standardized error messages - reduces code duplication"""
        if error_type == "critical":
            QtWidgets.QMessageBox.critical(self.main_window, title, message)
        elif error_type == "warning":
            QtWidgets.QMessageBox.warning(self.main_window, title, message)
        elif error_type == "information":
            QtWidgets.QMessageBox.information(self.main_window, title, message)
    
    def show_input_dialog(self, title, prompt, default_text=""):
        """Helper function to show standardized input dialogs - reduces code duplication"""
        return QtWidgets.QInputDialog.getText(
            self.main_window,
            title,
            prompt,
            QtWidgets.QLineEdit.Normal,
            default_text
        )
    
    def show_directory_dialog(self, title, default_dir=""):
        """Helper function to show standardized directory selection dialogs - reduces code duplication"""
        return QtWidgets.QFileDialog.getExistingDirectory(
            self.main_window,
            title,
            default_dir,
            QtWidgets.QFileDialog.ShowDirsOnly
        )
    
    def run_analysis_with_loading(self, title, analysis_function, *, run_in_thread=False):
        """Helper to run analysis with loading screen.
        Set run_in_thread=False if analysis_function touches GUI widgets.
        """
        self.show_loading_screen_with_function(title, analysis_function, run_in_thread=run_in_thread)
        
    def load_files_activity(self):
        """Load file activity related tables from the registry DB"""
        db_path = self.get_registry_db_path() if hasattr(self, 'get_registry_db_path') else 'registry_data.db'
        if not os.path.exists(db_path):
            print(f"[File Activity Error] Database file not found: {db_path}")
            self.show_error_message(
                "File Activity Data",
                f"Registry database not found at: {db_path}\nPlease collect registry data first.",
                "warning"
            )
            return
        
        mapping = {
            "Search_Explorer_bar": self.SearchViaExplorer_table,
            "RecentDocs": self.RecentDocs_table,
            "TypedPaths": self.TypedPath_table,
            "OpenSaveMRU": self.OpenSaveMRU_table,
            "lastSaveMRU": self.LastSaveMRU_table,
            "BAM": self.Bam_table,
            "DAM": self.Dam_table,
        }
        
        successful_loads = 0
        for table_name, widget in mapping.items():
            try:
                if self.load_registry_data_to_table(table_name, widget, db_path):
                    successful_loads += 1
            except Exception as e:
                print(f"[File Activity Error] Failed to load {table_name}: {str(e)}")
        
        if successful_loads > 0:
            print(f"[File Activity] Successfully loaded {successful_loads}/{len(mapping)} file activity tables")
        else:
            self.show_error_message(
                "File Activity Data",
                "No file activity data could be loaded from the database.",
                "warning"
            )
        
    def load_all_logs(self):
        """Load all Windows event logs into their tables"""
        db_path = self.get_log_db_path()
        self.load_data_with_error_handling(db_path, "SystemLogs", self.SystemLogs_table, "System Logs")
        self.load_data_with_error_handling(db_path, "ApplicationLogs", self.AppLogs_table, "Application Logs")
        self.load_data_with_error_handling(db_path, "SecurityLogs", self.SecurityLogs_table, "Security Logs")
        
    def load_data_from_Prefetch(self):
        """Load Prefetch database into the Prefetch table"""
        try:
            # Get proper database path based on case configuration
            if hasattr(self, 'case_paths') and self.case_paths:
                case_root = self.case_paths.get('case_root')
                artifacts_dir = self.case_paths.get('artifacts_dir')
                if artifacts_dir and os.path.exists(artifacts_dir):
                    db_path = os.path.join(artifacts_dir, 'prefetch.db')
                elif case_root:
                    db_path = os.path.join(case_root, 'Target_Artifacts', 'prefetch.db')
                else:
                    db_path = 'prefetch.db'
            else:
                db_path = 'prefetch.db'
            
            if not os.path.exists(db_path):
                print(f"[Prefetch Error] Database file not found: {db_path}")
                self.show_error_message(
                    "Prefetch Data",
                    f"Prefetch database not found at: {db_path}\nPlease collect prefetch data first.",
                    "warning"
                )
                return False
            
            success = self.load_registry_data_to_table("prefetch_data", self.Prefetch_table, db_path)
            if success:
                print(f"[Prefetch] Successfully loaded records from prefetch_data")
            else:
                self.show_error_message(
                    "Prefetch Data",
                    "Failed to load prefetch data from database.",
                    "warning"
                )
            return success
            
        except Exception as e:
            print(f"[Prefetch Error] Error loading prefetch data: {str(e)}")
            self.show_error_message(
                "Prefetch Data",
                f"Unexpected error loading prefetch data: {str(e)}",
                "critical"
            )
            return False
        
    def load_registry_data_from_db(self):
        """Load all registry data from the registry DB into GUI tables"""
        try:
            print("[Registry] Starting to load all registry data...")
            db_path = self.get_registry_db_path() if hasattr(self, 'get_registry_db_path') else 'registry_data_live.db'
            if not os.path.exists(db_path):
                print(f"[Registry Error] Database file not found: {db_path}")
                self.show_error_message(
                    "Registry Data",
                    f"Registry database not found at: {db_path}\nPlease collect registry data first.",
                    "warning"
                )
                return False
            table_mapping = {
                "computer_Name": self.computerName_table,
                "time_zone": self.TimeZone_table,
                "TimeZoneInfo": self.TimeZone_table,
                "network_interfaces": self.NetworkInterface_table,
                "NetworkInterfacesInfo": self.NetworkInterface_table,
                "Network_list": self.NetworkLists_table,
                "SystemServices": self.tableWidget_2,
                "machine_run": self.MachineRun_table,
                "machine_run_once": self.MachineRunOnce_tabel,
                "user_run": self.UserRun_table,
                "user_run_once": self.UserRunOnce_table,
                "Windows_lastupdate": self.LastUpdate_table,
                "WindowsUpdateInfo": self.LastUpdateInfo_table,
                "ShutdownInfo": self.ShutDown_table,
                "BrowserHistory": self.Browser_history_table,
                "USBDevices": self.tableWidget_3,
                "USBInstances": self.tableWidget_4,
                "USBProperties": self.tableWidget_5,
                "USBStorageDevices": self.tableWidget_6,
                "USBStorageVolumes": self.tableWidget_7,
                "RecentDocs": self.RecentDocs_table,
                "Search_Explorer_bar": self.SearchViaExplorer_table,
                "OpenSaveMRU": self.OpenSaveMRU_table,
                "lastSaveMRU": self.LastSaveMRU_table,
                "TypedPaths": self.TypedPath_table,
                "BAM": self.Bam_table,
                "DAM": self.Dam_table,
                "InstalledSoftware": self.tableWidget,
            }
            conn = sqlite3.connect(db_path)
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
            available_tables = [table[0] for table in cursor.fetchall()]
            for db_table, gui_table in table_mapping.items():
                if db_table in available_tables:
                    try:
                        cursor.execute(f"SELECT * FROM {db_table}")
                        rows = cursor.fetchall()
                        if rows:
                            # Ensure headers match table structure
                            cursor.execute(f"PRAGMA table_info({db_table})")
                            columns = [column[1] for column in cursor.fetchall()]
                            if gui_table.columnCount() != len(columns):
                                gui_table.setColumnCount(len(columns))
                                gui_table.setHorizontalHeaderLabels(columns)
                            gui_table.setRowCount(len(rows))
                            for r_idx, row in enumerate(rows):
                                for c_idx, value in enumerate(row):
                                    item = QtWidgets.QTableWidgetItem(str(value) if value is not None else "")
                                    item.setFlags(item.flags() & ~Qt.ItemIsEditable)
                                    gui_table.setItem(r_idx, c_idx, item)
                            gui_table.resizeColumnsToContents()
                    except Exception as e:
                        print(f"[Registry Error] Failed to load {db_table}: {str(e)}")
            conn.close()
            return True
        except Exception as e:
            print(f"[Registry Error] Couldn't load registry data: {str(e)}")
            return False
        
    def setupUi(self, Crow_Eye):
        self.main_window = Crow_Eye
        # Store search results
        self.search_results = []  # Will store tuples of (table, row, column)
        self.current_result_index = -1  # Current position in search results
        self.highlight_queue = collections.deque()
        self.highlight_timer = QtCore.QTimer()
        self.highlight_timer.setInterval(50)  # Process queue every 50ms
        self.highlight_timer.timeout.connect(self.process_highlight_queue)
        self.highlight_timer.start()
        self.is_processing_highlight = False
        # Initialize loading overlay
        self.loading_overlay = QtWidgets.QWidget(self.main_window)
        self.loading_overlay.hide()  # Hide by default
        self.loading_overlay.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint)
        self.loading_overlay.setAttribute(Qt.WA_TranslucentBackground)
        self.loading_overlay.setStyleSheet("background-color: rgba(0, 0, 0, 180);")
        Crow_Eye.setObjectName("Crow_Eye")
        Crow_Eye.resize(1516, 840)
        Crow_Eye.setSizeIncrement(QtCore.QSize(15, 0))
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(":/Icons/CrowEye.ico"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        Crow_Eye.setWindowIcon(icon)
        self.centralwidget = QtWidgets.QWidget(Crow_Eye)
        self.centralwidget.setObjectName("centralwidget")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.centralwidget)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setSpacing(0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.top_frame = QtWidgets.QFrame(self.centralwidget)
        self.top_frame.setStyleSheet(CrowEyeStyles.TOP_FRAME)
        self.top_frame.setFrameShape(QtWidgets.QFrame.NoFrame)
        self.top_frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.top_frame.setObjectName("top_frame")
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout(self.top_frame)
        self.horizontalLayout_3.setContentsMargins(10, 5, 10, 5)
        self.horizontalLayout_3.setSpacing(8)
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        
        # Left section: Menu button and case buttons
        self.left_section = QtWidgets.QHBoxLayout()
        self.left_section.setSpacing(8)
        self.left_section.setObjectName("left_section")
        
        # Menu button
        self.main_menu = QtWidgets.QPushButton(self.top_frame)
        self.main_menu.setEnabled(True)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.main_menu.sizePolicy().hasHeightForWidth())
        self.main_menu.setSizePolicy(sizePolicy)
        self.main_menu.setMinimumSize(QtCore.QSize(42, 42))
        self.main_menu.setMaximumSize(QtCore.QSize(42, 42))
        self.main_menu.setFont(self.create_rockwell_font(8, False))
        self.main_menu.setToolTip("Toggle Sidebar")
        self.main_menu.setAutoFillBackground(False)
        self.main_menu.setStyleSheet(CrowEyeStyles.MAIN_MENU_BUTTON)
        self.main_menu.setText("")
        icon1 = QtGui.QIcon()
        icon1.addPixmap(QtGui.QPixmap(":/Icons/icons/menu-icon.svg"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.main_menu.setIcon(icon1)
        self.main_menu.setIconSize(QtCore.QSize(42, 42))
        self.main_menu.setCheckable(True)
        self.main_menu.setChecked(True)
        self.main_menu.setFlat(False)
        self.main_menu.setObjectName("main_menu")
        self.left_section.addWidget(self.main_menu)
        
        # Small spacing after menu button
        self.left_section.addSpacing(10)
        
        # Create Case button
        self.Creat_case = QtWidgets.QPushButton(self.top_frame)
        self.Creat_case.setStyleSheet(CrowEyeStyles.CASE_BUTTON)
        self.Creat_case.setObjectName("Creat_case")
        self.Creat_case.setMaximumHeight(32)
        icon_new_case = QtGui.QIcon()
        icon_new_case.addPixmap(QtGui.QPixmap(":/Icons/icons/new-case-icon.svg"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.Creat_case.setIcon(icon_new_case)
        self.Creat_case.setIconSize(QtCore.QSize(20, 20))
        self.left_section.addWidget(self.Creat_case)
        
        # Open Case button
        self.open_case_btn = QtWidgets.QPushButton(self.top_frame)
        self.open_case_btn.setStyleSheet(CrowEyeStyles.CASE_BUTTON)
        self.open_case_btn.setObjectName("pushButton_2")
        self.open_case_btn.setMaximumHeight(32)
        icon_open_case = QtGui.QIcon()
        icon_open_case.addPixmap(QtGui.QPixmap(":/Icons/icons/open-case-icon.svg"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.open_case_btn.setIcon(icon_open_case)
        self.open_case_btn.setIconSize(QtCore.QSize(20, 20))
        self.left_section.addWidget(self.open_case_btn)
        
        # Add left section to main layout
        self.horizontalLayout_3.addLayout(self.left_section)
        
        # Center section: Case name label
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem)
        
        self.label = QtWidgets.QLabel(self.top_frame)
        self.label.setEnabled(True)
        self.label.setFont(self.create_rockwell_font(10, False))
        self.label.setAutoFillBackground(False)
        self.label.setStyleSheet(CrowEyeStyles.MAIN_LABEL)
        self.label.setAlignment(QtCore.Qt.AlignCenter)
        self.label.setObjectName("label")
        self.label.setSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        self.label.setMaximumWidth(300)
        self.horizontalLayout_3.addWidget(self.label)
        
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_3.addItem(spacerItem1)
        
        # Animate sidebar on main menu toggle
        self.main_menu.toggled.connect(self.toggle_sidebar)
        
        # Add search bar to the top frame
        self.search_frame = QtWidgets.QFrame(self.top_frame)
        self.search_frame.setStyleSheet(CrowEyeStyles.SEARCH_FRAME)
        self.search_frame.setFrameShape(QtWidgets.QFrame.NoFrame)
        self.search_frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.search_frame.setObjectName("search_frame")
        self.horizontalLayout_search = QtWidgets.QHBoxLayout(self.search_frame)
        self.horizontalLayout_search.setContentsMargins(5, 0, 5, 0)
        self.horizontalLayout_search.setSpacing(5)
        self.horizontalLayout_search.setObjectName("horizontalLayout_search")
        
        # Search label
        self.search_label = QtWidgets.QLabel(self.search_frame)
        self.search_label.setStyleSheet(CrowEyeStyles.SEARCH_LABEL)
        self.search_label.setText("Search:")
        self.search_label.setObjectName("search_label")
        self.horizontalLayout_search.addWidget(self.search_label)
        
        # Search input field
        self.search_input = QtWidgets.QLineEdit(self.search_frame)
        self.search_input.setMinimumWidth(150)
        self.search_input.setMaximumWidth(180)
        self.search_input.setStyleSheet(CrowEyeStyles.SEARCH_INPUT)
        self.search_input.setPlaceholderText("Search in all tables...")
        self.search_input.setClearButtonEnabled(True)
        self.search_input.setObjectName("search_input")
        self.search_input.returnPressed.connect(self.search_tables)
        self.horizontalLayout_search.addWidget(self.search_input)

        self.loading_label = QtWidgets.QLabel(self.search_frame)
        self.loading_label.setFixedSize(24, 24)
        self.loading_movie = QMovie(os.path.join('GUI Resources', 'loading.gif'))
        self.loading_movie.setScaledSize(QtCore.QSize(24, 24))
        self.loading_label.setMovie(self.loading_movie)
        self.loading_label.hide()
        self.horizontalLayout_search.addWidget(self.loading_label)
        
        # Search button
        self.search_button = QtWidgets.QPushButton(self.search_frame)
        self.search_button.setStyleSheet(CrowEyeStyles.GREEN_BUTTON)
        self.search_button.setText("Search")
        self.search_button.setObjectName("search_button")
        icon_search = QtGui.QIcon()
        icon_search.addPixmap(QtGui.QPixmap(":/Icons/icons/search-icon.svg"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.search_button.setIcon(icon_search)
        self.search_button.setIconSize(QtCore.QSize(16, 16))
        self.search_button.clicked.connect(self.search_tables)
        self.horizontalLayout_search.addWidget(self.search_button)
        
        # Previous result button
        self.prev_result_button = QtWidgets.QPushButton(self.search_frame)
        self.prev_result_button.setStyleSheet(CrowEyeStyles.NAVIGATION_BUTTON)
        self.prev_result_button.setText("Previous")
        self.prev_result_button.setObjectName("prev_result_button")
        self.prev_result_button.setEnabled(False)
        self.prev_result_button.clicked.connect(self.go_to_previous_result)
        self.horizontalLayout_search.addWidget(self.prev_result_button)
        
        # Next result button
        self.next_result_button = QtWidgets.QPushButton(self.search_frame)
        self.next_result_button.setStyleSheet(CrowEyeStyles.NAVIGATION_BUTTON)
        self.next_result_button.setText("Next")
        self.next_result_button.setObjectName("next_result_button")
        self.next_result_button.setEnabled(False)
        self.next_result_button.clicked.connect(self.go_to_next_result)
        self.horizontalLayout_search.addWidget(self.next_result_button)
        
        #  search button
        self._search_button = QtWidgets.QPushButton(self.search_frame)
        self._search_button.setStyleSheet(CrowEyeStyles.RED_BUTTON)
        self._search_button.setText("Clear")
        self._search_button.setObjectName("_search_button")
        self._search_button.setEnabled(False)
        self._search_button.clicked.connect(self.clear_search_results)
        self.horizontalLayout_search.addWidget(self._search_button)
        
        # Add the search frame to the top frame layout
        self.horizontalLayout_3.addWidget(self.search_frame)
        
        self.verticalLayout_2.addWidget(self.top_frame)
        self.Main_frame = QtWidgets.QFrame(self.centralwidget)
        self.Main_frame.setAutoFillBackground(False)
        self.Main_frame.setStyleSheet(CrowEyeStyles.MAIN_FRAME)
        self.Main_frame.setFrameShape(QtWidgets.QFrame.NoFrame)
        self.Main_frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.Main_frame.setObjectName("Main_frame")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout(self.Main_frame)
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        # Remove gaps so sidebar can reduce to exact 0 width
        self.horizontalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_2.setSpacing(0)
        self.side_fram = QtWidgets.QFrame(self.Main_frame)
        self.side_fram.setStyleSheet(CrowEyeStyles.SIDEBAR_FRAME)
        self.side_fram.setFrameShape(QtWidgets.QFrame.NoFrame)
        self.side_fram.setFrameShadow(QtWidgets.QFrame.Raised)
        self.side_fram.setObjectName("side_fram")
        # Fixed horizontal policy allows full collapse to 0
        try:
            sp = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Expanding)
            self.side_fram.setSizePolicy(sp)
            # Remove inner margins so it can collapse flush to 0
            self.side_fram.setContentsMargins(0, 0, 0, 0)
        except Exception:
            pass
        # Set initial sidebar size and state based on sizeHint
        try:
            self._sidebar_full_width = max(240, self.side_fram.sizeHint().width())
            self.side_fram.setMinimumWidth(self._sidebar_full_width)
            self.side_fram.setMaximumWidth(self._sidebar_full_width)
            self._sidebar_expanded = True
        except Exception:
            pass
        # Keep menu button state in sync with sidebar initial state
        try:
            self.main_menu.setChecked(True)
        except Exception:
            pass
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.side_fram)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        # Add small spacing between sidebar elements for better visual separation
        try:
            self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)
            self.verticalLayout_3.setSpacing(4)  # Small spacing between elements
        except Exception:
            pass
        self.exprot_json_CSV = QtWidgets.QPushButton(self.side_fram)
        self.exprot_json_CSV.setStyleSheet(CrowEyeStyles.GREEN_BUTTON)
        self.exprot_json_CSV.setObjectName("loadData")
        self.verticalLayout_3.addWidget(self.exprot_json_CSV)
        spacerItem2 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_3.addItem(spacerItem2)
        self.Live_analysis = QtWidgets.QLabel(self.side_fram)
        self.Live_analysis.setAutoFillBackground(False)
        self.Live_analysis.setStyleSheet(CrowEyeStyles.LIVE_ANALYSIS_LABEL)
        self.Live_analysis.setObjectName("Live_analysis")
        self.verticalLayout_3.addWidget(self.Live_analysis)
        # Small spacer after section label
        spacerItem_live = QtWidgets.QSpacerItem(20, 8, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        self.verticalLayout_3.addItem(spacerItem_live)
        self.parse_all = QtWidgets.QPushButton(self.side_fram)
        self.parse_all.setStyleSheet(CrowEyeStyles.PARSE_ALL_BUTTON)
        self.parse_all.setObjectName("parse_all")
        self.verticalLayout_3.addWidget(self.parse_all)
        self.registrybutton = QtWidgets.QPushButton(self.side_fram)
        self.registrybutton.setAutoFillBackground(False)
        self.setup_parse_button(self.registrybutton, True, True, True)
        self.registrybutton.setObjectName("registrybutton")
        self.verticalLayout_3.addWidget(self.registrybutton)
        self.lnkbutton = QtWidgets.QPushButton(self.side_fram)
        self.setup_parse_button(self.lnkbutton, True, True, False)
        self.lnkbutton.setObjectName("lnkbutton")
        self.verticalLayout_3.addWidget(self.lnkbutton)


        self.Prefetchbutton = QtWidgets.QPushButton(self.side_fram)
        # ... existing code ...
        self.setup_parse_button(self.Prefetchbutton, True, True, True)
        self.Prefetchbutton.setObjectName("Prefetchbutton")
        self.verticalLayout_3.addWidget(self.Prefetchbutton)
        
        self.ShimCacheButton = QtWidgets.QPushButton(self.side_fram)
        self.setup_parse_button(self.ShimCacheButton, True, True, True)
        self.ShimCacheButton.setObjectName("ShimCacheButton")
        self.verticalLayout_3.addWidget(self.ShimCacheButton)
        
        self.logbutton = QtWidgets.QPushButton(self.side_fram)
        self.setup_parse_button(self.logbutton, True, True, False)
        self.logbutton.setObjectName("logbutton")
        self.verticalLayout_3.addWidget(self.logbutton)
        spacerItem3 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_3.addItem(spacerItem3)
        self.Offline_analysis = QtWidgets.QLabel(self.side_fram)
        self.Offline_analysis.setStyleSheet(CrowEyeStyles.LIVE_ANALYSIS_LABEL)
        self.Offline_analysis.setObjectName("Offline_analysis")
        self.verticalLayout_3.addWidget(self.Offline_analysis)
        # Small spacer after section label
        spacerItem_offline = QtWidgets.QSpacerItem(20, 8, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        self.verticalLayout_3.addItem(spacerItem_offline)
        self.registry_offline = QtWidgets.QPushButton(self.side_fram)
        self.setup_parse_button(self.registry_offline, True, True, False)
        self.registry_offline.setObjectName("registry_offline")
        self.verticalLayout_3.addWidget(self.registry_offline)
        self.offline_LNK_JL = QtWidgets.QPushButton(self.side_fram)
        self.setup_parse_button(self.offline_LNK_JL, True, True, False)
        self.offline_LNK_JL.setObjectName("offline_LNK_JL")
        self.verticalLayout_3.addWidget(self.offline_LNK_JL)
        self.offline_prefetch = QtWidgets.QPushButton(self.side_fram)
        self.setup_parse_button(self.offline_prefetch, True, True, False)
        self.offline_prefetch.setObjectName("offline_prefetch")
        self.verticalLayout_3.addWidget(self.offline_prefetch)
        spacerItem4 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_3.addItem(spacerItem4)
        self.horizontalLayout_2.addWidget(self.side_fram)
        self.info_frame = QtWidgets.QFrame(self.Main_frame)
        self.info_frame.setFont(self.create_standard_font("MS Shell Dlg 2", 10, True, False))
        self.info_frame.setStyleSheet(CrowEyeStyles.TAB_BACKGROUND)
        self.info_frame.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.info_frame.setFrameShadow(QtWidgets.QFrame.Raised)
        self.info_frame.setObjectName("info_frame")
        # Ensure main content expands to take available space
        try:
            sp2 = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
            self.info_frame.setSizePolicy(sp2)
        except Exception:
            pass
        self.verticalLayout = QtWidgets.QVBoxLayout(self.info_frame)
        self.verticalLayout.setObjectName("verticalLayout")
        self.main_tab = QtWidgets.QTabWidget(self.info_frame)
        self.main_tab.setMinimumSize(QtCore.QSize(874, 750))
        self.main_tab.setBaseSize(QtCore.QSize(3000, 0))
        self.main_tab.setAutoFillBackground(False)
        self.main_tab.setIconSize(QtCore.QSize(30, 16))
        # Apply styles to tab widgets
        CrowEyeStyles.apply_tab_styles(self.main_tab, style_name="main")

        # Set object names for specific styling
        self.main_tab.setObjectName("main_tab")
        # Apply standard tab configuration with unified style
        self.setup_standard_tab_widget(self.main_tab, style_sheet=CrowEyeStyles.UNIFIED_TAB_STYLE)
        self.apply_custom_tab_style(self.main_tab)
        self.Registry_Tab = QtWidgets.QWidget()
        self.Registry_Tab.setObjectName("Registry_Tab")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.Registry_Tab)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.Registry_widget = QtWidgets.QTabWidget(self.Registry_Tab)
        self.Registry_widget.setObjectName("Registry_widget")
        CrowEyeStyles.apply_tab_styles(self.Registry_widget, style_name="sub")
        # Apply standard tab configuration with unified sub-tab styling
        self.setup_standard_tab_widget(self.Registry_widget, style_sheet=CrowEyeStyles.UNIFIED_TAB_STYLE)
        self.apply_custom_tab_style(self.Registry_widget)
        self.computer_Name = QtWidgets.QWidget()
        self.computer_Name.setAutoFillBackground(False)
        self.computer_Name.setObjectName("computer_Name")
        self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.computer_Name)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.computerName_table = QtWidgets.QTableWidget(self.computer_Name)
        self.setup_standard_table(self.computerName_table, 3, True, 300, 190)
        self.computerName_table.setObjectName("computerName_table")
        self.verticalLayout_6.addWidget(self.computerName_table)
        self.Registry_widget.addTab(self.computer_Name, "")
        self.Time_Zone = QtWidgets.QWidget()
        self.Time_Zone.setObjectName("Time_Zone")
        self.verticalLayout_7 = QtWidgets.QVBoxLayout(self.Time_Zone)
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.TimeZone_table = QtWidgets.QTableWidget(self.Time_Zone)
        self.setup_standard_table(self.TimeZone_table, 3, True, 300, 190)
        self.TimeZone_table.setObjectName("TimeZone_table")
        self.verticalLayout_7.addWidget(self.TimeZone_table)
        self.Registry_widget.addTab(self.Time_Zone, "")
        self.NetworkInterfaces_tab = QtWidgets.QWidget()
        self.NetworkInterfaces_tab.setObjectName("NetworkInterfaces_tab")
        self.verticalLayout_8 = QtWidgets.QVBoxLayout(self.NetworkInterfaces_tab)
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.NetworkInterface_table = QtWidgets.QTableWidget(self.NetworkInterfaces_tab)
        self.setup_standard_table(self.NetworkInterface_table, 4, True, 300, 190)
        self.NetworkInterface_table.setObjectName("NetworkInterface_table")
        self.verticalLayout_8.addWidget(self.NetworkInterface_table)
        self.Registry_widget.addTab(self.NetworkInterfaces_tab, "")
        self.Networklists = QtWidgets.QWidget()
        self.Networklists.setObjectName("Networklists")
        self.verticalLayout_9 = QtWidgets.QVBoxLayout(self.Networklists)
        self.verticalLayout_9.setObjectName("verticalLayout_9")
        self.NetworkLists_table = QtWidgets.QTableWidget(self.Networklists)
        self.setup_standard_table(self.NetworkLists_table, 4, True, 300, 190)
        self.NetworkLists_table.setObjectName("NetworkLists_table")
        self.verticalLayout_9.addWidget(self.NetworkLists_table)
        self.Registry_widget.addTab(self.Networklists, "")
        self.SystemServices = QtWidgets.QWidget()
        self.SystemServices.setObjectName("SystemServices")
        self.verticalLayout_33 = QtWidgets.QVBoxLayout(self.SystemServices)
        self.verticalLayout_33.setObjectName("verticalLayout_33")
        self.tableWidget_2 = QtWidgets.QTableWidget(self.SystemServices)
        self.setup_standard_table(self.tableWidget_2, 9, True, 300, 190)
        self.tableWidget_2.setObjectName("tableWidget_2")
        self.verticalLayout_33.addWidget(self.tableWidget_2)
        self.Registry_widget.addTab(self.SystemServices, "")
        self.MachineRun = QtWidgets.QWidget()
        self.MachineRun.setObjectName("MachineRun")
        self.verticalLayout_11 = QtWidgets.QVBoxLayout(self.MachineRun)
        self.verticalLayout_11.setObjectName("verticalLayout_11")
        self.MachineRun_table = QtWidgets.QTableWidget(self.MachineRun)
        self.setup_standard_table(self.MachineRun_table, 3, True, 300, 190)
        self.MachineRun_table.setObjectName("MachineRun_table")
        self.verticalLayout_11.addWidget(self.MachineRun_table)
        self.Registry_widget.addTab(self.MachineRun, "")
        self.Machine_run_once = QtWidgets.QWidget()
        self.Machine_run_once.setObjectName("Machine_run_once")
        self.verticalLayout_12 = QtWidgets.QVBoxLayout(self.Machine_run_once)
        self.verticalLayout_12.setObjectName("verticalLayout_12")
        self.MachineRunOnce_tabel = QtWidgets.QTableWidget(self.Machine_run_once)
        self.setup_standard_table(self.MachineRunOnce_tabel, 3, True, 300, 190)
        self.MachineRunOnce_tabel.setObjectName("MachineRunOnce_tabel")
        self.verticalLayout_12.addWidget(self.MachineRunOnce_tabel)
        self.Registry_widget.addTab(self.Machine_run_once, "")
        
        # ShimCache Tab
        self.ShimCache_tab = QtWidgets.QWidget()
        self.ShimCache_tab.setObjectName("ShimCache_tab")
        self.verticalLayout_shimcache = QtWidgets.QVBoxLayout(self.ShimCache_tab)
        self.verticalLayout_shimcache.setObjectName("verticalLayout_shimcache")
        self.ShimCache_table = QtWidgets.QTableWidget(self.ShimCache_tab)
        self.setup_standard_table(self.ShimCache_table, 6, True, 300, 190)
        self.ShimCache_table.setObjectName("ShimCache_table")
        self.verticalLayout_shimcache.addWidget(self.ShimCache_table)
        self.Registry_widget.addTab(self.ShimCache_tab, "")
        
        self.User_run = QtWidgets.QWidget()
        self.User_run.setObjectName("User_run")
        self.verticalLayout_13 = QtWidgets.QVBoxLayout(self.User_run)
        self.verticalLayout_13.setObjectName("verticalLayout_13")
        self.UserRun_table = QtWidgets.QTableWidget(self.User_run)
        self.UserRun_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.UserRun_table, 3, True, 300, 190)
        self.UserRun_table.setObjectName("UserRun_table")
        self.verticalLayout_13.addWidget(self.UserRun_table)
        self.Registry_widget.addTab(self.User_run, "")
        
        # ShimCache tab was moved to main tab
        
        self.User_run_once = QtWidgets.QWidget()
        self.User_run_once.setObjectName("User_run_once")
        self.verticalLayout_14 = QtWidgets.QVBoxLayout(self.User_run_once)
        self.verticalLayout_14.setObjectName("verticalLayout_14")
        self.UserRunOnce_table = QtWidgets.QTableWidget(self.User_run_once)
        self.UserRunOnce_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.UserRunOnce_table, 3, True, 300, 190)
        self.UserRunOnce_table.setObjectName("UserRunOnce_table")
        self.verticalLayout_14.addWidget(self.UserRunOnce_table)
        self.Registry_widget.addTab(self.User_run_once, "")
        self.Last_update = QtWidgets.QWidget()
        self.Last_update.setObjectName("Last_update")
        self.verticalLayout_15 = QtWidgets.QVBoxLayout(self.Last_update)
        self.verticalLayout_15.setObjectName("verticalLayout_15")
        self.LastUpdate_table = QtWidgets.QTableWidget(self.Last_update)
        self.setup_standard_table(self.LastUpdate_table, 3, True, 300, 190)
        self.LastUpdate_table.setObjectName("LastUpdate_table")
        self.verticalLayout_15.addWidget(self.LastUpdate_table)
        self.Registry_widget.addTab(self.Last_update, "")
        self.Lstupdate_info = QtWidgets.QWidget()
        self.Lstupdate_info.setObjectName("Lstupdate_info")
        self.verticalLayout_16 = QtWidgets.QVBoxLayout(self.Lstupdate_info)
        self.verticalLayout_16.setObjectName("verticalLayout_16")
        self.LastUpdateInfo_table = QtWidgets.QTableWidget(self.Lstupdate_info)
        self.setup_standard_table(self.LastUpdateInfo_table, 4, True, 300, 190)
        self.LastUpdateInfo_table.setObjectName("LastUpdateInfo_table")
        self.verticalLayout_16.addWidget(self.LastUpdateInfo_table)
        self.Registry_widget.addTab(self.Lstupdate_info, "")
        self.ShutDown_tab = QtWidgets.QWidget()
        self.ShutDown_tab.setObjectName("ShutDown_tab")
        self.verticalLayout_18 = QtWidgets.QVBoxLayout(self.ShutDown_tab)
        self.verticalLayout_18.setObjectName("verticalLayout_18")
        self.ShutDown_table = QtWidgets.QTableWidget(self.ShutDown_tab)
        self.setup_standard_table(self.ShutDown_table, 3, True, 300, 190)
        self.ShutDown_table.setObjectName("ShutDown_table")
        self.verticalLayout_18.addWidget(self.ShutDown_table)
        self.Registry_widget.addTab(self.ShutDown_tab, "")
        self.Browser_history = QtWidgets.QWidget()
        self.Browser_history.setObjectName("Browser_history")
        self.verticalLayout_31 = QtWidgets.QVBoxLayout(self.Browser_history)
        self.verticalLayout_31.setObjectName("verticalLayout_31")
        self.Browser_history_table = QtWidgets.QTableWidget(self.Browser_history)
        self.Browser_history_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.Browser_history_table, 6, True, 300, 190)
        self.Browser_history_table.setObjectName("Browser_history_table")
        self.verticalLayout_31.addWidget(self.Browser_history_table)
        self.Registry_widget.addTab(self.Browser_history, "")
        
        # ShimCache tab was moved to main tab
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout(self.tab)
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.tableWidget_3 = QtWidgets.QTableWidget(self.tab)
        self.tableWidget_3.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.tableWidget_3, 5, True, 300, 190)
        self.tableWidget_3.setObjectName("tableWidget_3")
        self.horizontalLayout_4.addWidget(self.tableWidget_3)
        self.Registry_widget.addTab(self.tab, "")
        self.tab_2 = QtWidgets.QWidget()
        self.tab_2.setObjectName("tab_2")
        self.verticalLayout_34 = QtWidgets.QVBoxLayout(self.tab_2)
        self.verticalLayout_34.setObjectName("verticalLayout_34")
        self.tableWidget_4 = QtWidgets.QTableWidget(self.tab_2)
        self.tableWidget_4.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.tableWidget_4, 5, True, 300, 190)
        self.tableWidget_4.setObjectName("tableWidget_4")
        self.verticalLayout_34.addWidget(self.tableWidget_4)
        self.Registry_widget.addTab(self.tab_2, "")
        self.tab_3 = QtWidgets.QWidget()
        self.tab_3.setObjectName("tab_3")
        self.verticalLayout_35 = QtWidgets.QVBoxLayout(self.tab_3)
        self.verticalLayout_35.setObjectName("verticalLayout_35")
        self.tableWidget_5 = QtWidgets.QTableWidget(self.tab_3)
        self.setup_standard_table(self.tableWidget_5, 4, True, 300, 190)
        self.tableWidget_5.setObjectName("tableWidget_5")
        self.verticalLayout_35.addWidget(self.tableWidget_5)
        self.Registry_widget.addTab(self.tab_3, "")
        self.tab_4 = QtWidgets.QWidget()
        self.tab_4.setObjectName("tab_4")
        self.verticalLayout_36 = QtWidgets.QVBoxLayout(self.tab_4)
        self.verticalLayout_36.setObjectName("verticalLayout_36")
        self.tableWidget_6 = QtWidgets.QTableWidget(self.tab_4)
        self.setup_standard_table(self.tableWidget_6, 9, True, 300, 190)
        self.tableWidget_6.setObjectName("tableWidget_6")
        self.verticalLayout_36.addWidget(self.tableWidget_6)
        self.Registry_widget.addTab(self.tab_4, "")
        self.tab_5 = QtWidgets.QWidget()
        self.tab_5.setObjectName("tab_5")
        self.verticalLayout_37 = QtWidgets.QVBoxLayout(self.tab_5)
        self.verticalLayout_37.setObjectName("verticalLayout_37")
        self.tableWidget_7 = QtWidgets.QTableWidget(self.tab_5)
        self.setup_standard_table(self.tableWidget_7, 5, True, 300, 190)
        self.tableWidget_7.setObjectName("tableWidget_7")
        self.verticalLayout_37.addWidget(self.tableWidget_7)
        self.Registry_widget.addTab(self.tab_5, "")
        self.verticalLayout_4.addWidget(self.Registry_widget)
        self.main_tab.addTab(self.Registry_Tab, "")
        self.filesActivity_tab = QtWidgets.QWidget()
        self.filesActivity_tab.setObjectName("filesActivity_tab")
        self.verticalLayout_17 = QtWidgets.QVBoxLayout(self.filesActivity_tab)
        self.verticalLayout_17.setObjectName("verticalLayout_17")
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.verticalLayout_17.addLayout(self.horizontalLayout_5)
        self.filesActivityTab_tables = QtWidgets.QTabWidget(self.filesActivity_tab)
        self.filesActivityTab_tables.setObjectName("filesActivityTab_tables")
        CrowEyeStyles.apply_tab_styles(self.filesActivityTab_tables, style_name="sub")
        # Apply standard tab configuration with unified sub-tab styling
        self.setup_standard_tab_widget(self.filesActivityTab_tables, style_sheet=CrowEyeStyles.SUB_TAB_WIDGET)
        self.apply_custom_tab_style(self.filesActivityTab_tables, "sub")
        self.Recent_docs_tab = QtWidgets.QWidget()
        self.Recent_docs_tab.setObjectName("Recent_docs_tab")
        self.verticalLayout_19 = QtWidgets.QVBoxLayout(self.Recent_docs_tab)
        self.verticalLayout_19.setObjectName("verticalLayout_19")
        self.RecentDocs_table = QtWidgets.QTableWidget(self.Recent_docs_tab)
        self.RecentDocs_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.RecentDocs_table, 4, True, 300, 190)
        self.RecentDocs_table.setObjectName("RecentDocs_table")
        self.verticalLayout_19.addWidget(self.RecentDocs_table)
        self.filesActivityTab_tables.addTab(self.Recent_docs_tab, "")
        self.SearchViaExplorerbar_tab = QtWidgets.QWidget()
        self.SearchViaExplorerbar_tab.setObjectName("SearchViaExplorerbar_tab")
        self.verticalLayout_20 = QtWidgets.QVBoxLayout(self.SearchViaExplorerbar_tab)
        self.verticalLayout_20.setObjectName("verticalLayout_20")
        self.SearchViaExplorer_table = QtWidgets.QTableWidget(self.SearchViaExplorerbar_tab)
        self.SearchViaExplorer_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.SearchViaExplorer_table, 3, True, 300, 190)
        self.SearchViaExplorer_table.setObjectName("SearchViaExplorer_table")
        self.verticalLayout_20.addWidget(self.SearchViaExplorer_table)
        self.filesActivityTab_tables.addTab(self.SearchViaExplorerbar_tab, "")
        self.OpenSaveMru = QtWidgets.QWidget()
        self.OpenSaveMru.setObjectName("OpenSaveMru")
        self.verticalLayout_21 = QtWidgets.QVBoxLayout(self.OpenSaveMru)
        self.verticalLayout_21.setObjectName("verticalLayout_21")
        self.OpenSaveMRU_table = QtWidgets.QTableWidget(self.OpenSaveMru)
        self.OpenSaveMRU_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.OpenSaveMRU_table, 4, True, 300, 190)
        self.OpenSaveMRU_table.setObjectName("OpenSaveMRU_table")
        self.verticalLayout_21.addWidget(self.OpenSaveMRU_table)
        self.filesActivityTab_tables.addTab(self.OpenSaveMru, "")
        self.LastSaveMRU_tab = QtWidgets.QWidget()
        self.LastSaveMRU_tab.setObjectName("LastSaveMRU_tab")
        self.verticalLayout_22 = QtWidgets.QVBoxLayout(self.LastSaveMRU_tab)
        self.verticalLayout_22.setObjectName("verticalLayout_22")
        self.LastSaveMRU_table = QtWidgets.QTableWidget(self.LastSaveMRU_tab)
        self.LastSaveMRU_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.LastSaveMRU_table, 4, True, 300, 190)
        self.LastSaveMRU_table.setObjectName("LastSaveMRU_table")
        self.verticalLayout_22.addWidget(self.LastSaveMRU_table)
        self.filesActivityTab_tables.addTab(self.LastSaveMRU_tab, "")
        self.TypedPathes_tab = QtWidgets.QWidget()
        self.TypedPathes_tab.setObjectName("TypedPathes_tab")
        self.verticalLayout_23 = QtWidgets.QVBoxLayout(self.TypedPathes_tab)
        self.verticalLayout_23.setObjectName("verticalLayout_23")
        self.TypedPath_table = QtWidgets.QTableWidget(self.TypedPathes_tab)
        self.TypedPath_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.TypedPath_table, 3, True, 300, 190)
        self.TypedPath_table.setObjectName("TypedPath_table")
        self.verticalLayout_23.addWidget(self.TypedPath_table)
        self.filesActivityTab_tables.addTab(self.TypedPathes_tab, "")
        self.BAM_tab = QtWidgets.QWidget()
        self.BAM_tab.setObjectName("BAM_tab")
        self.verticalLayout_25 = QtWidgets.QVBoxLayout(self.BAM_tab)
        self.verticalLayout_25.setObjectName("verticalLayout_25")
        self.Bam_table = QtWidgets.QTableWidget(self.BAM_tab)
        self.setup_standard_table(self.Bam_table, 4, True, 300, 190)
        self.Bam_table.setObjectName("Bam_table")
        self.verticalLayout_25.addWidget(self.Bam_table)
        self.filesActivityTab_tables.addTab(self.BAM_tab, "")
        self.Dam_tab = QtWidgets.QWidget()
        self.Dam_tab.setObjectName("Dam_tab")
        self.verticalLayout_24 = QtWidgets.QVBoxLayout(self.Dam_tab)
        self.verticalLayout_24.setObjectName("verticalLayout_24")
        self.Dam_table = QtWidgets.QTableWidget(self.Dam_tab)
        self.setup_standard_table(self.Dam_table, 4, True, 300, 190)
        self.Dam_table.setObjectName("Dam_table")
        self.verticalLayout_24.addWidget(self.Dam_table)
        self.filesActivityTab_tables.addTab(self.Dam_tab, "")
        self.Installed_sowftare = QtWidgets.QWidget()
        self.Installed_sowftare.setObjectName("Installed_sowftare")
        self.verticalLayout_32 = QtWidgets.QVBoxLayout(self.Installed_sowftare)
        self.verticalLayout_32.setObjectName("verticalLayout_32")
        self.tableWidget = QtWidgets.QTableWidget(self.Installed_sowftare)
        self.setup_standard_table(self.tableWidget, 7, True, 300, 190)
        self.tableWidget.setObjectName("tableWidget")
        self.verticalLayout_32.addWidget(self.tableWidget)
        self.filesActivityTab_tables.addTab(self.Installed_sowftare, "")
        self.verticalLayout_17.addWidget(self.filesActivityTab_tables)
        self.main_tab.addTab(self.filesActivity_tab, "")
        self.Prefetch_tab = QtWidgets.QWidget()
        self.Prefetch_tab.setObjectName("Prefetch_tab")
        self.verticalLayout_26 = QtWidgets.QVBoxLayout(self.Prefetch_tab)
        self.verticalLayout_26.setObjectName("verticalLayout_26")
        self.Prefetch_table = QtWidgets.QTableWidget(self.Prefetch_tab)
        self.Prefetch_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.Prefetch_table, 31, False, 300, 190)
        self.Prefetch_table.setObjectName("Prefetch_table")
        self.verticalLayout_26.addWidget(self.Prefetch_table)
        # Use purple header for Prefetch table
        try:
            pref_hdr = self.Prefetch_table.horizontalHeader()
            pref_hdr.setObjectName("header_purple")
            pref_hdr.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
        except Exception:
            pass
        self.main_tab.addTab(self.Prefetch_tab, "")
        self.LNK_AL_Tab = QtWidgets.QWidget()
        self.LNK_AL_Tab.setStyleSheet(CrowEyeStyles.TAB_BACKGROUND)
        self.LNK_AL_Tab.setObjectName("LNK_AL_Tab")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.LNK_AL_Tab)
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.verticalLayout_5.addLayout(self.horizontalLayout)
        self.LNK_table = QtWidgets.QTableWidget(self.LNK_AL_Tab)
        self.LNK_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.LNK_table, 33, False, 300, 190)
        self.LNK_table.setObjectName("LNK_table")
        # ... existing code ...
        self.verticalLayout_5.addWidget(self.LNK_table)
        self.main_tab.addTab(self.LNK_AL_Tab, "")
        self.CJL_Tab = QtWidgets.QWidget()
        self.CJL_Tab.setObjectName("CJL_Tab")
        self.verticalLayout_10 = QtWidgets.QVBoxLayout(self.CJL_Tab)
        self.verticalLayout_10.setObjectName("verticalLayout_10")
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        self.verticalLayout_10.addLayout(self.horizontalLayout_10)
        self.Clj_table = QtWidgets.QTableWidget(self.CJL_Tab)
        self.Clj_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.Clj_table, 33, False, 300, 190)
        self.Clj_table.setObjectName("Clj_table")
        self.verticalLayout_10.addWidget(self.Clj_table)
        self.main_tab.addTab(self.CJL_Tab, "")
        self.Logs_tab = QtWidgets.QWidget()
        self.Logs_tab.setObjectName("Logs_tab")
        self.verticalLayout_27 = QtWidgets.QVBoxLayout(self.Logs_tab)
        self.verticalLayout_27.setObjectName("verticalLayout_27")
        # Create and configure the tab widget
        self.tabWidget = QtWidgets.QTabWidget(self.Logs_tab)
        self.tabWidget.setObjectName("tabWidget")
        CrowEyeStyles.apply_tab_styles(self.tabWidget, style_name="sub")
        
        # Apply standard configuration with unified tab style
        self.setup_standard_tab_widget(self.tabWidget, style_sheet=CrowEyeStyles.UNIFIED_TAB_STYLE)
        self.apply_custom_tab_style(self.tabWidget)
        self.setup_standard_tab_background(self.tabWidget)
        self.AppLogs_tab = QtWidgets.QWidget()
        self.AppLogs_tab.setObjectName("AppLogs_tab")
        self.verticalLayout_28 = QtWidgets.QVBoxLayout(self.AppLogs_tab)
        self.verticalLayout_28.setObjectName("verticalLayout_28")
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.verticalLayout_28.addLayout(self.horizontalLayout_7)
        self.AppLogs_table = QtWidgets.QTableWidget(self.AppLogs_tab)
        self.AppLogs_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.AppLogs_table, 9, True, 300, 190)
        self.AppLogs_table.setObjectName("AppLogs_table")
        self.verticalLayout_28.addWidget(self.AppLogs_table)
        self.tabWidget.addTab(self.AppLogs_tab, "")
        self.SecurityLogs_tab = QtWidgets.QWidget()
        self.SecurityLogs_tab.setObjectName("SecurityLogs_tab")
        self.verticalLayout_29 = QtWidgets.QVBoxLayout(self.SecurityLogs_tab)
        self.verticalLayout_29.setObjectName("verticalLayout_29")
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.verticalLayout_29.addLayout(self.horizontalLayout_8)
        self.SecurityLogs_table = QtWidgets.QTableWidget(self.SecurityLogs_tab)
        self.SecurityLogs_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.SecurityLogs_table, 10, True, 300, 190)
        self.SecurityLogs_table.setObjectName("SecurityLogs_table")
        self.verticalLayout_29.addWidget(self.SecurityLogs_table)
        self.tabWidget.addTab(self.SecurityLogs_tab, "")
        self.SystemLogs_tab = QtWidgets.QWidget()
        self.SystemLogs_tab.setObjectName("SystemLogs_tab")
        self.verticalLayout_30 = QtWidgets.QVBoxLayout(self.SystemLogs_tab)
        self.verticalLayout_30.setObjectName("verticalLayout_30")
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        self.verticalLayout_30.addLayout(self.horizontalLayout_9)
        self.SystemLogs_table = QtWidgets.QTableWidget(self.SystemLogs_tab)
        self.SystemLogs_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.SystemLogs_table, 9, True, 300, 190)
        self.SystemLogs_table.setObjectName("SystemLogs_table")
        self.verticalLayout_30.addWidget(self.SystemLogs_table)
        self.tabWidget.addTab(self.SystemLogs_tab, "")
        self.verticalLayout_27.addWidget(self.tabWidget)
        self.main_tab.addTab(self.Logs_tab, "")
        
        # Create ShimCache main tab
        self.ShimCache_main_tab = QtWidgets.QWidget()
        self.ShimCache_main_tab.setObjectName("ShimCache_main_tab")
        self.verticalLayout_shimcache_main = QtWidgets.QVBoxLayout(self.ShimCache_main_tab)
        self.verticalLayout_shimcache_main.setObjectName("verticalLayout_shimcache_main")
        
        # Create ShimCache table
        self.ShimCache_main_table = QtWidgets.QTableWidget(self.ShimCache_main_tab)
        self.ShimCache_main_table.setMinimumSize(QtCore.QSize(2, 2))
        self.setup_standard_table(self.ShimCache_main_table, 5, True, 300, 190)
        self.ShimCache_main_table.setObjectName("ShimCache_main_table")
        self.verticalLayout_shimcache_main.addWidget(self.ShimCache_main_table)
        
        # Add ShimCache tab to main tab widget
        self.main_tab.addTab(self.ShimCache_main_tab, "")
        
        self.verticalLayout.addWidget(self.main_tab)
        self.horizontalLayout_2.addWidget(self.info_frame)
        # Give all stretch to content and none to sidebar
        try:
            self.horizontalLayout_2.setStretch(0, 0)
            self.horizontalLayout_2.setStretch(1, 1)
        except Exception:
            pass
        self.verticalLayout_2.addWidget(self.Main_frame)
        self.verticalLayout_2.setStretch(0, 1)
        self.verticalLayout_2.setStretch(1, 30)
        Crow_Eye.setCentralWidget(self.centralwidget)

        self.retranslateUi(Crow_Eye)
        self.main_tab.setCurrentIndex(2)
        self.Registry_widget.setCurrentIndex(0)
        self.filesActivityTab_tables.setCurrentIndex(5)
        self.tabWidget.setCurrentIndex(2)
        # Remove conflicting hide/show connections; animation handles visibility/width
        QtCore.QMetaObject.connectSlotsByName(Crow_Eye)
        Crow_Eye.setTabOrder(self.lnkbutton, self.logbutton)
        Crow_Eye.setTabOrder(self.logbutton, self.main_tab)
        Crow_Eye.setTabOrder(self.main_tab, self.main_menu)
        Crow_Eye.setTabOrder(self.main_menu, self.LNK_table)
        Crow_Eye.setTabOrder(self.LNK_table, self.registrybutton)

   



    def retranslateUi(self, Crow_Eye):
        _translate = QtCore.QCoreApplication.translate
        Crow_Eye.setWindowTitle(_translate("Crow_Eye", "Crow Eye"))
        
        # Refresh all tables to apply styles
        QtCore.QTimer.singleShot(100, self.refresh_all_tables)
        # Enable sorting for all tables
        self.enable_sorting_for_all_tables()
        self.label.setText(_translate("Crow_Eye", "Case name"))
        self.open_case_btn.setText(_translate("Crow_Eye", "Open case"))
        self.Creat_case.setText(_translate("Crow_Eye", "Creat case"))
        self.exprot_json_CSV.setText(_translate("Crow_Eye", "exprot as json and CSV"))
        self.Live_analysis.setText(_translate("Crow_Eye", "Live analysis "))
        self.parse_all.setText(_translate("Crow_Eye", "parse all Artifacts"))
        self.registrybutton.setText(_translate("Crow_Eye", "Registry"))
        self.lnkbutton.setText(_translate("Crow_Eye", "LNK and A-JL"))

        self.Prefetchbutton.setText(_translate("Crow_Eye", "Prefetch"))
        self.ShimCacheButton.setText(_translate("Crow_Eye", "ShimCache"))
        self.logbutton.setText(_translate("Crow_Eye", "Logs"))
        self.Offline_analysis.setText(_translate("Crow_Eye", "offline analysis"))
        self.registry_offline.setText(_translate("Crow_Eye", "Registry offline"))
        self.offline_LNK_JL.setText(_translate("Crow_Eye", "Lnk and JL offline"))
        self.offline_prefetch.setText(_translate("Crow_Eye", "offline_Prefetch"))

        # Initialize computerName_table headers
        if hasattr(self, 'computerName_table'):
            self.computerName_table.setColumnCount(3)
            for i, header in enumerate(["Name", "Data", "Data Type"]):
                item = QtWidgets.QTableWidgetItem()
                self.computerName_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        if hasattr(self, 'computer_Name'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.computer_Name), 
                _translate("Crow_Eye", "Computer name")
            )
            
        # Initialize TimeZone_table headers
        if hasattr(self, 'TimeZone_table'):
            self.TimeZone_table.setColumnCount(3)
            for i, header in enumerate(["Name", "Data", "Data Type"]):
                item = QtWidgets.QTableWidgetItem()
                self.TimeZone_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        # Set tab text for Time Zone tab
        if hasattr(self, 'Time_Zone') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.Time_Zone),
                _translate("Crow_Eye", "Time Zone")
            )
            
        # Initialize NetworkInterface_table headers
        if hasattr(self, 'NetworkInterface_table'):
            self.NetworkInterface_table.setColumnCount(4)
            headers = ["Sub Key name", "Service", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.NetworkInterface_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
                
        # Set tab text for Network Interfaces tab
        if hasattr(self, 'NetworkInterfaces_tab') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.NetworkInterfaces_tab),
                _translate("Crow_Eye", "Network Interfaces")
            )
        # Initialize NetworkLists_table headers
        if hasattr(self, 'NetworkLists_table'):
            self.NetworkLists_table.setColumnCount(4)
            headers = ["Sub Key Name", "Service", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.NetworkLists_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
                
        # Set tab text for Network Lists tab
        if hasattr(self, 'Networklists') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.Networklists),
                _translate("Crow_Eye", "Network Lists")
            )
            
        # Initialize tableWidget_2 headers if it exists
        # Initialize tableWidget_2 headers if it exists
        if hasattr(self, 'tableWidget_2'):
            headers = [
                "Service Name", "Display Name", "Description",
                "Image Path", "Start type", "Service Type",
                "Error Control", "Status", "Analysis time"
            ]
            self.tableWidget_2.setColumnCount(len(headers))
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.tableWidget_2.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for System Services tab
        if hasattr(self, 'SystemServices') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.SystemServices),
                _translate("Crow_Eye", "System services")
            )
        
        # Initialize MachineRun_table headers if it exists
        if hasattr(self, 'MachineRun_table'):
            self.MachineRun_table.setColumnCount(3)
            headers = ["Name", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.MachineRun_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header.strip()))
        
        # Set tab text for Machine Run tab
        if hasattr(self, 'MachineRun') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.MachineRun),
                _translate("Crow_Eye", "Machine_Run")
            )
        
        # Initialize MachineRunOnce_table headers if it exists
        if hasattr(self, 'MachineRunOnce_tabel'):
            self.MachineRunOnce_tabel.setColumnCount(3)
            for i, header in enumerate(["Name", "Data", "Data Type"]):
                item = QtWidgets.QTableWidgetItem()
                self.MachineRunOnce_tabel.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Machine Run Once tab
        if hasattr(self, 'Machine_run_once') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.Machine_run_once),
                _translate("Crow_Eye", "Machine_run_once")
            )
        
        # Initialize UserRun_table headers if it exists
        if hasattr(self, 'UserRun_table'):
            self.UserRun_table.setColumnCount(3)
            for i, header in enumerate(["Name", "Data", "Data Type"]):
                item = QtWidgets.QTableWidgetItem()
                self.UserRun_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for User Run tab
        if hasattr(self, 'User_run') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.User_run),
                _translate("Crow_Eye", "User_Run")
            )
            
        # Initialize ShimCache_table headers if it exists (for Registry widget)
        if hasattr(self, 'ShimCache_table'):
            self.ShimCache_table.setColumnCount(5)
            headers = ["Filename", "Path", "Last Modified (Epoch)", "Last Modified", "Parsed Timestamp"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.ShimCache_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Initialize ShimCache_main_table headers for main tab
        if hasattr(self, 'ShimCache_main_table'):
            self.ShimCache_main_table.setColumnCount(5)
            headers = ["Filename", "Path", "Last Modified (Epoch)", "Last Modified", "Parsed Timestamp"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.ShimCache_main_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for ShimCache main tab
        if hasattr(self, 'ShimCache_main_tab') and hasattr(self, 'main_tab'):
            self.main_tab.setTabText(
                self.main_tab.indexOf(self.ShimCache_main_tab),
                _translate("Crow_Eye", "ShimCache")
            )
            
        # Set tab text for ShimCache tab (in Registry widget)
        if hasattr(self, 'ShimCache_tab') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.ShimCache_tab),
                _translate("Crow_Eye", "ShimCache")
            )
        
        # Initialize UserRunOnce_table headers if it exists
        if hasattr(self, 'UserRunOnce_table'):
            self.UserRunOnce_table.setColumnCount(3)
            for i, header in enumerate(["Name", "Data", "Data Type"]):
                item = QtWidgets.QTableWidgetItem()
                self.UserRunOnce_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for User Run Once tab
        if hasattr(self, 'User_run_once') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.User_run_once),
                _translate("Crow_Eye", "User_run_once")
            )
        
        # Initialize LastUpdate_table headers if it exists
        if hasattr(self, 'LastUpdate_table'):
            self.LastUpdate_table.setColumnCount(3)
            for i, header in enumerate(["Name", "Data", "Data Type"]):
                item = QtWidgets.QTableWidgetItem()
                self.LastUpdate_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Last Update tab
        if hasattr(self, 'Last_update') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.Last_update),
                _translate("Crow_Eye", "Last Update")
            )
        
        # Initialize LastUpdateInfo_table headers if it exists
        if hasattr(self, 'LastUpdateInfo_table'):
            self.LastUpdateInfo_table.setSortingEnabled(True)
            self.LastUpdateInfo_table.setColumnCount(4)
            headers = ["Sub key Name", "Service", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.LastUpdateInfo_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Last Update Info tab
        if hasattr(self, 'Lstupdate_info') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.Lstupdate_info),
                _translate("Crow_Eye", "Last update info")
            )
        
        # Initialize ShutDown_table headers if it exists
        if hasattr(self, 'ShutDown_table'):
            self.ShutDown_table.setColumnCount(3)
            for i, header in enumerate(["Name", "Data", "Data Type"]):
                item = QtWidgets.QTableWidgetItem()
                self.ShutDown_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Shutdown info tab
        if hasattr(self, 'ShutDown_tab') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.ShutDown_tab),
                _translate("Crow_Eye", "Shutdown info")
            )
        
        # Initialize Browser_history_table headers if it exists
        if hasattr(self, 'Browser_history_table'):
            self.Browser_history_table.setColumnCount(6)
            headers = ["Browser", "URL", "Title", "Visit count", "Last visit", "Time stamp"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.Browser_history_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Browser History tab
        if hasattr(self, 'Browser_history') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.Browser_history),
                _translate("Crow_Eye", "Browser History")
            )
            
        # Initialize ShimCache_table headers if it exists
        if hasattr(self, 'ShimCache_table'):
            self.ShimCache_table.setColumnCount(5)
            headers = ["Filename", "Path", "Last Modified", "Last Modified (Readable)", "Parsed Timestamp"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.ShimCache_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for ShimCache tab
        if hasattr(self, 'ShimCache_tab') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.ShimCache_tab),
                _translate("Crow_Eye", "ShimCache")
            )
        
        # Initialize tableWidget_3 headers if it exists (USB Devices)
        if hasattr(self, 'tableWidget_3'):
            self.tableWidget_3.setColumnCount(5)
            headers = ["Device ID", "Description", "Manufacture", "Name of the USB", "Last Connected"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.tableWidget_3.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for USB Devices tab
        if hasattr(self, 'tab') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.tab),
                _translate("Crow_Eye", "USB Devices")
            )
        
        # Initialize tableWidget_4 headers if it exists (USB Instance)
        if hasattr(self, 'tableWidget_4'):
            self.tableWidget_4.setColumnCount(6)
            headers = ["Device ID", "Instance ID", "Parent ID", "Service", "Status", "Description"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.tableWidget_4.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for USB Instance tab
        if hasattr(self, 'tab_2') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.tab_2),
                _translate("Crow_Eye", "USB Instance")
            )
        
        # Initialize tableWidget_5 headers if it exists (USB Properties)
        if hasattr(self, 'tableWidget_5'):
            self.tableWidget_5.setColumnCount(4)
            headers = ["Device ID", "Property Name", "Property Value", "Property Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.tableWidget_5.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for USB Properties tab
        if hasattr(self, 'tab_3') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.tab_3),
                _translate("Crow_Eye", "USB Properties")
            )
        
        # Initialize tableWidget_6 headers if it exists (USB History)
        if hasattr(self, 'tableWidget_6'):
            self.tableWidget_6.setColumnCount(9)
            headers = [
                "Device ID", "Friendly Name", "Serial Number",
                "Vendor ID", "Product ID", "Revision",
                "First Connected", "Last connected", "Analyzing Time"
            ]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.tableWidget_6.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for USB Storage Devices tab
        if hasattr(self, 'tab_4') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.tab_4),
                _translate("Crow_Eye", "USB Storage Devices")
            )
        
        # Initialize tableWidget_7 headers if it exists (USB Storage Volumes)
        if hasattr(self, 'tableWidget_7'):
            self.tableWidget_7.setColumnCount(5)
            headers = ["Device ID", "Volume GUID", "Volume Name", "Drive Letter", "Time Stamp"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.tableWidget_7.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for USB Storage Volumes tab
        if hasattr(self, 'tab_5') and hasattr(self, 'Registry_widget'):
            self.Registry_widget.setTabText(
                self.Registry_widget.indexOf(self.tab_5),
                _translate("Crow_Eye", "USB Storage Volumes")
            )
        
        # Set main tab text for Registry
        if hasattr(self, 'main_tab') and hasattr(self, 'Registry_Tab'):
            self.main_tab.setTabText(
                self.main_tab.indexOf(self.Registry_Tab),
                _translate("Crow_Eye", "Registry")
            )
        
        # Initialize RecentDocs_table headers if it exists
        if hasattr(self, 'RecentDocs_table'):
            self.RecentDocs_table.setColumnCount(4)
            headers = ["Sub Key Name", "Service", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.RecentDocs_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Recent Docs tab
        if hasattr(self, 'Recent_docs_tab') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.Recent_docs_tab),
                _translate("Crow_Eye", "Recent Docs")
            )
        
        # Initialize SearchViaExplorer_table headers if it exists
        if hasattr(self, 'SearchViaExplorer_table'):
            self.SearchViaExplorer_table.setColumnCount(3)
            headers = ["Name", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.SearchViaExplorer_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header.strip()))
        
        # Set tab text for Search via Explorer bar tab
        if hasattr(self, 'SearchViaExplorerbar_tab') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.SearchViaExplorerbar_tab),
                _translate("Crow_Eye", "Search via Explorer bar")
            )
        
        # Initialize OpenSaveMRU_table headers if it exists
        if hasattr(self, 'OpenSaveMRU_table'):
            self.OpenSaveMRU_table.setColumnCount(4)
            headers = ["Sub key Name", "Service", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.OpenSaveMRU_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header.strip()))
        
        # Set tab text for Open Save MRU tab
        if hasattr(self, 'OpenSaveMru') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.OpenSaveMru),
                _translate("Crow_Eye", "Open Save MRU")
            )
        
        # Initialize LastSaveMRU_table headers if it exists
        if hasattr(self, 'LastSaveMRU_table'):
            self.LastSaveMRU_table.setColumnCount(4)
            headers = ["Name", "Data", "Data Type", "PID"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.LastSaveMRU_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Last Save MRU tab
        if hasattr(self, 'LastSaveMRU_tab') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.LastSaveMRU_tab),
                _translate("Crow_Eye", "Last Save MRU")
            )
        
        # Initialize TypedPath_table headers if it exists
        if hasattr(self, 'TypedPath_table'):
            self.TypedPath_table.setColumnCount(3)
            headers = ["Name", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.TypedPath_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header.strip()))
        
        # Set tab text for Typed Paths tab
        if hasattr(self, 'TypedPathes_tab') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.TypedPathes_tab),
                _translate("Crow_Eye", "Typed Paths")
            )
        
        # Initialize Bam_table headers if it exists (BAM)
        if hasattr(self, 'Bam_table'):
            self.Bam_table.setColumnCount(4)
            headers = ["Sub Key Name", "Service", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.Bam_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header.strip()))
        
        # Set tab text for BAM tab
        if hasattr(self, 'BAM_tab') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.BAM_tab),
                _translate("Crow_Eye", "BAM")
            )
        
        # Initialize Dam_table headers if it exists (DAM)
        if hasattr(self, 'Dam_table'):
            self.Dam_table.setColumnCount(4)
            headers = ["Sub Key Name", "Service", "Data", "Data Type"]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.Dam_table.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header.strip()))
        
        # Set tab text for DAM tab
        if hasattr(self, 'Dam_tab') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.Dam_tab),
                _translate("Crow_Eye", "DAM")
            )
        
        # Set tooltip for Installed Software
        if hasattr(self, 'Installed_sowftare'):
            self.Installed_sowftare.setToolTip(_translate(
                "Crow_Eye",
                "<html><head/><body><p>Installed Software</p><p><br/></p></body></html>"
            ))
        
        # Initialize tableWidget headers if it exists (Installed Software)
        if hasattr(self, 'tableWidget'):
            self.tableWidget.setColumnCount(7)
            headers = [
                "Name", "Version", "Publisher", "Install Date",
                "Install Location", "Uninstall String", "Analyzing Date"
            ]
            for i, header in enumerate(headers):
                item = QtWidgets.QTableWidgetItem()
                self.tableWidget.setHorizontalHeaderItem(i, item)
                item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Installed Software tab
        if hasattr(self, 'Installed_sowftare') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.Installed_sowftare),
                _translate("Crow_Eye", "Installed Software")
            )
        
        # Set main tab text for Files Activity
        if hasattr(self, 'main_tab') and hasattr(self, 'filesActivity_tab'):
            self.main_tab.setTabText(
                self.main_tab.indexOf(self.filesActivity_tab),
                _translate("Crow_Eye", "Files Activity")
            )
        
        # Initialize Prefetch_table headers if it exists
        if hasattr(self, 'Prefetch_table'):
            self.Prefetch_table.setColumnCount(31)  # Total number of columns in the table
            headers = [
                "ID", "Executable Name", "File Path", "Version", "Size",
                "Modified Time", "Creation Time", "Access Time", "Run Count",
                "Volume Serial", "Inode Number", "Device", "Number Links",
                "UID", "GID", "Run Count", "Last Runs", "Duration MS",
                "Duration Last MS", "Calculated Hash", "Stored Hash",
                "Hash Match", "Volume Info", "Suspicious Volumes", "Volume Stats",
                "All files references", "Suspicious Files", "Dll loading",
                "Directory Stats", "File Stats", "Forensics Flags", "Analyzing Time"
            ]
            for i, header in enumerate(headers):
                if i < self.Prefetch_table.columnCount():  # Ensure we don't exceed column count
                    item = QtWidgets.QTableWidgetItem()
                    self.Prefetch_table.setHorizontalHeaderItem(i, item)
                    item.setText(_translate("Crow_Eye", header))
        
        # Set tab text for Prefetch tab if it exists
        if hasattr(self, 'tab_9') and hasattr(self, 'filesActivityTab_tables'):
            self.filesActivityTab_tables.setTabText(
                self.filesActivityTab_tables.indexOf(self.tab_9),
                _translate("Crow_Eye", "Prefetch")
            )
        
        # Set main tab text for Prefetch tab
        if hasattr(self, 'main_tab') and hasattr(self, 'Prefetch_tab'):
            self.main_tab.setTabText(
                self.main_tab.indexOf(self.Prefetch_tab),
                _translate("Crow_Eye", "Prefetch")
            )
        
        # Initialize LNK_table headers if it exists
        if hasattr(self, 'LNK_table'):
            self.LNK_table.setSortingEnabled(True)
            self.LNK_table.setColumnCount(33)  # Total number of columns in the table
            headers = [
                "Source_Name", "Source_path", "Owner UID", "Owner GID", "Time_Access",
                "Time_Creation", "Time_modefication", "app_Type", "App_ID",
                "Artifact", "Dataflag", "Local_Path", "Common Path", "Location_Flags",
                "Volume_Label", "Local_Base_Path", "Relative_Path", "Working_Dir",
                "Command_Line_Arguments", "Icon_Location", "Show_Window_Command",
                "Hot_Key_Flags", "Hot_Key_Value", "File_Attributes_Flags",
                "File_Size", "Drive_Type", "Drive_Serial_Number", "Volume_Name",
                "Network_Providers", "Network_share_Flags", "Network_Share_Name",
                "Network_Share_Name_UNI", "File_Permission", "Number of the hardlinks",
                "Device_ID", "Inode number"
            ]
            for i, header in enumerate(headers):
                if i < self.LNK_table.columnCount():  # Ensure we don't exceed column count
                    item = QtWidgets.QTableWidgetItem()
                    self.LNK_table.setHorizontalHeaderItem(i, item)
                    item.setText(_translate("Crow_Eye", header))
            
            # Set main tab text for LNK tab if it exists
            if hasattr(self, 'main_tab') and hasattr(self, 'LNK_AL_Tab'):
                self.main_tab.setTabText(
                    self.main_tab.indexOf(self.LNK_AL_Tab),
                    _translate("Crow_Eye", "LNK and A_JL")
                )
        # Initialize Clj_table headers if it exists
        if hasattr(self, 'Clj_table'):
            self.Clj_table.setSortingEnabled(True)
            self.Clj_table.setColumnCount(13)  # Total number of columns in the table
            headers = [
                "File name", "File Directory", "Owner UID", "Owner GID", "Access time",
                "Creation Time", "Modification Time", "File Size", "File permission", "File Type",
                "numbers_hard_links", "Device_id", "Inode number", "Artifact"
            ]
            for i, header in enumerate(headers):
                if i < self.Clj_table.columnCount():  # Ensure we don't exceed column count
                    item = QtWidgets.QTableWidgetItem()
                    self.Clj_table.setHorizontalHeaderItem(i, item)
                    item.setText(_translate("Crow_Eye", header))
            
            # Set main tab text for CJL tab if it exists
            if hasattr(self, 'main_tab') and hasattr(self, 'CJL_Tab'):
                self.main_tab.setTabText(
                    self.main_tab.indexOf(self.CJL_Tab),
                    _translate("Crow_Eye", "C-JL")
                )
        # Initialize AppLogs_table headers if it exists
        if hasattr(self, 'AppLogs_table'):
            self.AppLogs_table.setSortingEnabled(True)
            self.AppLogs_table.setColumnCount(9)  # Total number of columns in the table
            headers = [
                "Event ID", "Source", "Event Type", "Category", "Time",
                "Computer Name", "User", "Key words", "Event Description"
            ]
            for i, header in enumerate(headers):
                if i < self.AppLogs_table.columnCount():  # Ensure we don't exceed column count
                    item = QtWidgets.QTableWidgetItem()
                    self.AppLogs_table.setHorizontalHeaderItem(i, item)
                    item.setText(_translate("Crow_Eye", header))
            
            # Set tab text for AppLogs tab if it exists
            if hasattr(self, 'tabWidget') and hasattr(self, 'AppLogs_tab'):
                self.tabWidget.setTabText(
                    self.tabWidget.indexOf(self.AppLogs_tab),
                    _translate("Crow_Eye", "Application Logs")
                )
        # Initialize SecurityLogs_table headers if it exists
        if hasattr(self, 'SecurityLogs_table'):
            self.SecurityLogs_table.setSortingEnabled(True)
            self.SecurityLogs_table.setColumnCount(10)  # Total number of columns in the table
            headers = [
                "Event ID", "Source", "Event Type", "Category", "Time",
                "Computer Name", "User", "Key words", "Task Level", "Event Description"
            ]
            for i, header in enumerate(headers):
                if i < self.SecurityLogs_table.columnCount():  # Ensure we don't exceed column count
                    item = QtWidgets.QTableWidgetItem()
                    self.SecurityLogs_table.setHorizontalHeaderItem(i, item)
                    item.setText(_translate("Crow_Eye", header))
            
            # Set tab text for Security Logs tab if it exists
            if hasattr(self, 'tabWidget') and hasattr(self, 'SecurityLogs_tab'):
                self.tabWidget.setTabText(
                    self.tabWidget.indexOf(self.SecurityLogs_tab),
                    _translate("Crow_Eye", "Security Logs")
                )
        # Initialize SystemLogs_table headers if it exists
        if hasattr(self, 'SystemLogs_table'):
            self.SystemLogs_table.setSortingEnabled(True)
            self.SystemLogs_table.setColumnCount(9)  # Total number of columns in the table
            headers = [
                "Event ID", "Source", "Event Type", "Category", "Time",
                "Computer Name", "User", "Key words", "Event Description"
            ]
            for i, header in enumerate(headers):
                if i < self.SystemLogs_table.columnCount():  # Ensure we don't exceed column count
                    item = QtWidgets.QTableWidgetItem()
                    self.SystemLogs_table.setHorizontalHeaderItem(i, item)
                    item.setText(_translate("Crow_Eye", header))
            
            # Set tab text for System Logs tab if it exists
            if hasattr(self, 'tabWidget') and hasattr(self, 'SystemLogs_tab'):
                self.tabWidget.setTabText(
                    self.tabWidget.indexOf(self.SystemLogs_tab),
                    _translate("Crow_Eye", "System Logs")
                )
        
        # Set main tab text for Logs tab if it exists
        if hasattr(self, 'main_tab') and hasattr(self, 'Logs_tab'):
            self.main_tab.setTabText(
                self.main_tab.indexOf(self.Logs_tab),
                _translate("Crow_Eye", "Logs")
            )



               

                
        # Connect data loading buttons with enhanced cyberpunk loading
        self.lnkbutton.clicked.connect(lambda: self.show_loading_screen_with_function(
            "LOADING LNK DATA", self.load_data_from_database_lnkAJL))

        self.logbutton.clicked.connect(self.load_all_logs)
        
        # Keep existing analysis button connections
        self.lnkbutton.clicked.connect(self.run_lnk_analysis)
        self.registrybutton.clicked.connect(self.run_registry_analysis)
        self.logbutton.clicked.connect(self.run_logs_analysis)
        self.Prefetchbutton.clicked.connect(self.run_prefetch_analysis)
        self.ShimCacheButton.clicked.connect(self.run_shimcache_analysis)
        self.exprot_json_CSV.clicked.connect(self.export_all_tables)    
        self.Creat_case.clicked.connect(self.create_directory)
        self.open_case_btn.clicked.connect(self.open_existing_case)
        # Connect parse_all button to live artifacts collection
        self.parse_all.clicked.connect(lambda: self.run_analysis_with_loading(
            "Running All Live Artifacts Analysis...", self.parse_all_live_artifacts))

        self.offline_prefetch.clicked.connect(self.run_offline_prefetch_analysis)
        self.offline_LNK_JL.clicked.connect(self.run_offline_lnk_analysis)
        self.registry_offline.clicked.connect(self.run_offline_registry_analysis)



    def get_app_config_dir(self):
        """Get the configuration and default case directories"""
        app_dir = os.path.dirname(os.path.abspath(__file__))
        config_dir = os.path.join(app_dir, 'config')
        os.makedirs(config_dir, exist_ok=True)
        # Use user's Documents\CrowEye as default cases root if available, fallback to C:\
        user_docs = os.path.join(os.path.expanduser('~'), 'Documents', 'CrowEye')
        default_dir = user_docs if os.path.isdir(os.path.dirname(user_docs)) else r"c:\\"
        os.makedirs(default_dir, exist_ok=True)
        return config_dir, default_dir

    def save_last_case(self, case_config):
        """Persist the last opened/created case info."""
        config_dir, _ = self.get_app_config_dir()
        last_case_path = os.path.join(config_dir, 'last_case.json')
        try:
            with open(last_case_path, 'w') as f:
                json.dump(case_config, f, indent=4)
        except Exception as e:
            print(f"[Error] Failed to save last case: {str(e)}")

    def load_last_case(self):
        """Load the last used case by delegating to open_case()."""
        config_dir, _ = self.get_app_config_dir()
        last_case_file = os.path.join(config_dir, 'last_case.json')
        if not os.path.exists(last_case_file):
            return False
        try:
            with open(last_case_file, 'r') as f:
                case_config = json.load(f)
            directory_path = case_config.get('paths', {}).get('case_root')
            if not directory_path or not os.path.exists(directory_path):
                return False
            self.open_case(directory_path)
            return True
        except Exception as e:
            print(f"[Error] Failed to load last case: {str(e)}")
            return False

    def open_case(self, directory_path=None):
        """Open and load a case.
        If directory_path is None, prompt the user to pick a directory.
        """
        # Ask for directory if not provided
        config_dir, default_cases_dir = self.get_app_config_dir()
        if directory_path is None:
            directory_path = QFileDialog.getExistingDirectory(
                self.main_window,
                "Select Case Directory",
                default_cases_dir,
                QFileDialog.ShowDirsOnly
            )
            if not directory_path:
                return None

        try:
            # Ensure artifacts directory exists
            artifacts_dir = os.path.join(directory_path, "Target_Artifacts")
            os.makedirs(artifacts_dir, exist_ok=True)
            # Store paths
            self.case_paths = {
                'case_root': directory_path,
                'artifacts_dir': artifacts_dir,
                'c_ajl_lnk_dir': os.path.join(artifacts_dir, "C_AJL_Lnk"),
                'registry_dir': os.path.join(artifacts_dir, "Registry_Hives"),
                'prefetch_dir': os.path.join(artifacts_dir, "Prefetch"),
            }
            for p in self.case_paths.values():
                os.makedirs(p, exist_ok=True)
            # Update UI
            case_name = os.path.basename(directory_path)
            self.label.setText(f"Case name: {case_name}")
            # Save case config and mark as last
            case_config = {
                'case_name': case_name,
                'opened_date': datetime.datetime.now().isoformat(),
                'paths': self.case_paths,
                'databases': {
                    'registry': os.path.join(self.case_paths['artifacts_dir'], 'registry_data.db'),
                    'lnk': os.path.join(self.case_paths['artifacts_dir'], 'LnkDB.db'),
                    'logs': os.path.join(self.case_paths['artifacts_dir'], 'Log_Claw.db'),
                    'prefetch': os.path.join(self.case_paths['artifacts_dir'], 'prefetch.db'),
                    'shimcache': os.path.join(self.case_paths['artifacts_dir'], 'shimcache.db')
                }
            }
            config_path = os.path.join(config_dir, f"case_{case_name}.json")
            with open(config_path, 'w') as f:
                json.dump(case_config, f, indent=4)
            self.save_last_case(case_config)
        
            # Check if this is a new case (no database files exist yet)
            db_files_exist = any(os.path.exists(db_path) for db_path in case_config['databases'].values())
        
            if not db_files_exist:
                # Only run full analysis for new cases
                print(f"[Open Case] New case detected, running full analysis for case: {case_name}")
                self.run_analysis_with_loading("Running All Analyses...", self.parse_all_live_artifacts)
            else:
                # For existing cases, just load the existing data
                print(f"[Open Case] Loading existing case data for: {case_name}")
                self.run_analysis_with_loading("Loading Case Data...", self.load_all_data)
        
            print(f"[Open Case] Successfully opened case: {case_name}")
            return self.case_paths
        except Exception as e:
            QMessageBox.critical(
                self.main_window,
                "Error",
                f"Failed to open case:\n{str(e)}"
            )
            return None

    def animate_progress_bar(self, progress_bar):
        """Animate the progress bar to make it more visible"""
        # For indeterminate progress bars, we can change the text to show activity
        current_text = progress_bar.text()
        if not current_text:
            progress_bar.setText("Processing")
        elif current_text == "Processing":
            progress_bar.setText("Processing.")
        elif current_text == "Processing.":
            progress_bar.setText("Processing..")
        elif current_text == "Processing..":
            progress_bar.setText("Processing...")
        else:
            progress_bar.setText("Processing")

    def load_case_config(self, case_name):
        """Load case configuration from file"""
        config_dir, _ = self.get_app_config_dir()  # Get config dir only
        config_path = os.path.join(config_dir, f"case_{case_name}.json")
        
        try:
            with open(config_path, 'r') as config_file:
                return json.load(config_file)
        except Exception as e:
            QMessageBox.critical(
                self.main_window,
                "Error",
                f"Failed to load case configuration:\n{str(e)}"
            )
            return None

    def clear_all_tables(self):
        """Clear all table widgets in the GUI"""
        # Clear all tables in the GUI
        tables_to_clear = [
            # Registry tables
            self.computerName_table, self.TimeZone_table, self.NetworkInterface_table,
            self.NetworkLists_table, self.MachineRun_table, self.UserRun_table,
            self.UserRunOnce_table, self.LastUpdate_table, self.LastUpdateInfo_table,
            self.ShutDown_table, self.Browser_history_table,
            # Files activity tables
            self.RecentDocs_table, self.SearchViaExplorer_table, self.OpenSaveMRU_table,
            self.LastSaveMRU_table, self.TypedPath_table, self.Bam_table, self.Dam_table,
            # Prefetch table
            self.Prefetch_table,
            # LNK and JL tables
            self.LNK_table, self.Clj_table,
            # Logs table
            self.AppLogs_table
        ]
        
        for table in tables_to_clear:
            table.setRowCount(0)
        
        self.clear_search_results()
    
    def hide_loading_screen(self):
        """Hide the loading screen"""
        try:
            if hasattr(self, 'loading_overlay') and self.loading_overlay:
                self.loading_overlay.hide()
                # Don't deleteLater here as it can cause issues with rapid show/hide
                # Just hide it and let it be reused
        except Exception as e:
            print(f"Error hiding loading screen: {e}")
            # Try to clean up if possible
            if hasattr(self, 'loading_overlay'):
                try:
                    self.loading_overlay.deleteLater()
                except:
                    pass
                    
    def clear_search_results(self):
        """Clear search results and reset search UI"""
        # Clear search results
        self.search_results = []
        self.current_result_index = -1
        
        # Clear search input if it exists
        if hasattr(self, 'search_input'):
            self.search_input.clear()
        
        # Update navigation buttons
        if hasattr(self, 'prev_result_button'):
            self.prev_result_button.setEnabled(False)
        if hasattr(self, 'next_result_button'):
            self.next_result_button.setEnabled(False)
        if hasattr(self, '_search_button'):
            self._search_button.setEnabled(False)
            
        # Clear any highlighting
        self.clear_highlighting()
        
    
    def close_all_database_connections(self):
        """Close any open database connections"""
        # SQLite doesn't maintain persistent connections, but we'll ensure any open ones are closed
        # This is a safety measure to ensure no connections are left open
        import gc
        for obj in gc.get_objects():
            if isinstance(obj, sqlite3.Connection):
                try:
                    obj.close()
                except Exception:
                    pass
    
    def create_directory(self):
        """Create case directory structure and store paths in class variables"""
        self.Creat_case.setEnabled(False)
        
        try:
            # Clear all tables and close database connections before creating a new case
            self.clear_all_tables()
            self.close_all_database_connections()
            
            # Get config directory and default cases directory
            config_dir, default_cases_dir = self.get_app_config_dir()
            
            # Get parent directory, starting from the default cases directory
            directory_path = QFileDialog.getExistingDirectory(
                self.main_window,
                "Select Parent Directory",
                default_cases_dir,  # Start in the default cases directory
                QFileDialog.ShowDirsOnly
            )
            
            if not directory_path:  # User cancelled
                self.Creat_case.setEnabled(True)
                return None
                
            # Get case directory name
            dir_name, ok = QInputDialog.getText(
                self.main_window,
                "Case Directory Name", 
                "Enter name for new case:",
                QLineEdit.Normal,
                "New_Case"
            )
            
            if not ok or not dir_name.strip():
                self.Creat_case.setEnabled(True)
                return None
                
            # Store paths as class variables
            self.case_paths = {
                'case_root': os.path.join(directory_path, dir_name),
                'artifacts_dir': os.path.join(os.path.join(directory_path, dir_name), "Target_Artifacts"),
                'c_ajl_lnk_dir': os.path.join(os.path.join(directory_path, dir_name), "Target_Artifacts/C_AJL_Lnk"),
                'registry_dir': os.path.join(os.path.join(directory_path, dir_name), "Target_Artifacts/Registry_Hives"),
                'prefetch_dir': os.path.join(os.path.join(directory_path, dir_name), "Target_Artifacts/Prefetch"),
            }
            
            # Create case configuration
            case_config = {
                'case_name': dir_name,
                'created_date': datetime.datetime.now().isoformat(),
                'paths': self.case_paths,
                'databases': {
                    'registry': os.path.join(self.case_paths['artifacts_dir'], 'registry_data.db'),
                    'lnk': os.path.join(self.case_paths['artifacts_dir'], 'LnkDB.db'),
                    'logs': os.path.join(self.case_paths['artifacts_dir'], 'Log_Claw.db'),
                    'prefetch': os.path.join(self.case_paths['artifacts_dir'], 'prefetch.db'),
                    'shimcache': os.path.join(self.case_paths['artifacts_dir'], 'shimcache.db')
                }
            }
            
            # Save configuration to application directory - FIX HERE
            config_path = os.path.join(config_dir, f"case_{dir_name}.json")
            
            # Create all directories
            created_dirs = []
            try:
                for dir_path in self.case_paths.values():
                    os.makedirs(dir_path, exist_ok=True)
                    created_dirs.append(dir_path)
                
                # Save case configuration
                with open(config_path, 'w') as config_file:
                    json.dump(case_config, config_file, indent=4)
                    
                # Update UI with case name
                self.label.setText(f"Case name: {dir_name}")
                    
                QMessageBox.information(
                    self.main_window,
                    "Case Initialized",
                    f"Case directories created successfully at:\n{self.case_paths['case_root']}"
                )
                
                return self.case_paths
                
            except Exception as e:
                # Clean up on error
                for dir_path in reversed(created_dirs):
                    try:
                        os.rmdir(dir_path)
                    except:
                        pass
                        
                if os.path.exists(config_path):
                    try:
                        os.remove(config_path)
                    except:
                        pass
                        
                QMessageBox.critical(
                    self.main_window,
                    "Error",
                    f"Failed to create case structure:\n{str(e)}"
                )
                self.case_paths = None
                return None
        
        except Exception as e:
            QMessageBox.critical(
                self.main_window,
                "Error",
                f"Failed to create case:\n{str(e)}"
            )
            return None
            
        finally:
            self.Creat_case.setEnabled(True)

    def open_existing_case(self):
        """Compatibility wrapper that delegates to open_case()."""
        return self.open_case()

    def show_loading_screen_with_function(self, title, function_to_run, *args, run_in_thread=False, **kwargs):
        """Show enhanced cyberpunk loading screen while running a function"""
        try:
            # Import the loading dialog
            from ui.Loading_dialog import LoadingDialog
            
            # Create and configure the loading dialog with cyberpunk style
            loading_dialog = LoadingDialog(
                title="CROW EYE SYSTEM",
                parent=self.main_window
            )
            
            # Apply the cyberpunk style to the dialog
            loading_dialog.setStyleSheet(CrowEyeStyles.LOADING_DIALOG)
            
            # Apply title style
            title_label = loading_dialog.findChild(QtWidgets.QLabel, "titleLabel")
            if title_label:
                title_label.setStyleSheet(CrowEyeStyles.OVERLAY_TITLE)
            
            # Apply status style
            status_label = loading_dialog.findChild(QtWidgets.QLabel, "statusLabel")
            if status_label:
                status_label.setStyleSheet(CrowEyeStyles.OVERLAY_STATUS)
            
            # Apply progress bar style
            progress_bar = loading_dialog.findChild(QtWidgets.QProgressBar)
            if progress_bar:
                progress_bar.setStyleSheet(CrowEyeStyles.OVERLAY_PROGRESS)
            
            # Apply log text style
            log_text = loading_dialog.findChild(QtWidgets.QTextEdit)
            if log_text:
                log_text.setStyleSheet(CrowEyeStyles.OVERLAY_LOG)
            
            # Show the dialog
            loading_dialog.show()
            QtWidgets.QApplication.processEvents()
            
            # Start log capture
            loading_dialog.start_log_capture()
            
            try:
                # Run the function directly on the main thread
                # This is safer and simpler for GUI operations
                result = function_to_run(*args, **kwargs)
                
                # Show completion with success style
                loading_dialog.show_completion("OPERATION COMPLETED SUCCESSFULLY")
                QtWidgets.QApplication.processEvents()
                
                # Keep dialog open for a moment to show completion
                QtCore.QTimer.singleShot(1500, loading_dialog.close)
                
                # Wait a bit for user to see the completion
                QtCore.QTimer.singleShot(2000, lambda: None)  # Brief pause
                
                return result
                
            except Exception as ex:
                # Show error with error style
                error_msg = f"[Error] Operation failed: {str(ex)}"
                loading_dialog.add_log_message(error_msg)
                QtWidgets.QApplication.processEvents()
                
                # Keep error dialog open longer
                QtCore.QTimer.singleShot(3000, loading_dialog.close)
                print(f"Error in operation: {str(ex)}")
                raise
                
            finally:
                # Always stop log capture
                loading_dialog.stop_log_capture()
                
        except ImportError as e:
            print(f"Warning: Could not load loading dialog: {e}")
            # Fallback to simple progress dialog with cyberpunk style
            progress_dialog = QtWidgets.QProgressDialog(title, "Cancel", 0, 0, self.main_window)
            progress_dialog.setWindowTitle("Crow Eye - Processing")
            progress_dialog.setWindowModality(Qt.WindowModal)
            progress_dialog.setMinimumDuration(0)
            progress_dialog.setCancelButton(None)
            
            # Apply cyberpunk style to progress dialog
            progress_dialog.setStyleSheet("""
                QProgressDialog {
                    background-color: #0B1220;
                    color: #00FFFF;
                    border: 2px solid #00FFFF;
                    border-radius: 5px;
                }
                QLabel {
                    color: #E5E7EB;
                    font-weight: bold;
                }
                QProgressBar {
                    border: 2px solid #00FFFF;
                    border-radius: 5px;
                    background: #1E293B;
                    text-align: center;
                    color: #E5E7EB;
                }
                QProgressBar::chunk {
                    background-color: #00FFFF;
                    width: 20px;
                }
            """)
            
            progress_bar = progress_dialog.findChild(QtWidgets.QProgressBar)
            if progress_bar:
                progress_bar.setTextVisible(False)
                progress_bar.setStyleSheet(CrowEyeStyles.OVERLAY_PROGRESS)
            
            progress_dialog.show()
            QtWidgets.QApplication.processEvents()
            
            try:
                result = function_to_run(*args, **kwargs)
                progress_dialog.setLabelText("Operation completed successfully!")
                QtWidgets.QApplication.processEvents()
                QtCore.QTimer.singleShot(500, progress_dialog.close)
                return result
            except Exception as ex:
                progress_dialog.setLabelText(f"Error: {str(ex)}")
                QtWidgets.QApplication.processEvents()
                QtCore.QTimer.singleShot(2000, progress_dialog.close)
                raise
                
        except Exception as e:
            print(f"Error in loading screen: {str(e)}")
            raise
            

    def run_lnk_analysis(self):
        """Run LNK analysis with loading screen"""
        self.run_analysis_with_loading("Running LNK Analysis...", self.parse_LNK_files)
        
    def run_registry_analysis(self):
        """Run registry analysis with loading screen"""
        self.run_analysis_with_loading("Running Registry Analysis...", self.parse_live_registry)

    
    def run_prefetch_analysis(self):
        """Run prefetch analysis with loading screen"""
        self.run_analysis_with_loading("Running Prefetch Analysis...", self.parse_perfetch)
    
    def run_shimcache_analysis(self):
        """Run ShimCache analysis with loading screen and switch to ShimCache tab"""
        self.run_analysis_with_loading("Running ShimCache Analysis...", self.parse_shimcache)
        # Switch to the ShimCache main tab
        self.main_tab.setCurrentIndex(self.main_tab.indexOf(self.ShimCache_main_tab))
    
    def run_logs_analysis(self):
        """Run Windows logs analysis with loading screen"""
        self.run_analysis_with_loading("Running Windows Logs Analysis...", self.parse_logs)
    
    def run_offline_lnk_analysis(self):
        """Run offline LNK analysis with loading screen"""
        self.run_analysis_with_loading("Running Offline LNK Analysis...", self.parse_offline_lnk_files)
    
    def run_offline_registry_analysis(self):
        """Run offline registry analysis with loading screen"""
        self.run_analysis_with_loading("Running Offline Registry Analysis...", self.parse_offline_registry)
    
    def run_offline_prefetch_analysis(self):
        """Run offline prefetch analysis with loading screen"""
        self.run_analysis_with_loading("Running Offline Prefetch Analysis...", self.parse_offline_prefetch)
    
    def parse_LNK_files(self):
        """Parse LNK files and Jump Lists"""
        try:
            print("[LNK] Starting LNK and Jump Lists collection...")
            from Artifacts_Collectors.A_CJL_LNK_Claw import A_CJL_LNK_Claw
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            A_CJL_LNK_Claw(case_path=case_root, offline_mode=False)
            print("[LNK] LNK and Jump Lists collected successfully")
            # Load the data into the UI
            self.load_data_from_database_lnkAJL()
            self.load_data_from_database_CJL()
        except Exception as e:
            print(f"[LNK Error] {str(e)}")
            raise
    
    def parse_live_registry(self):
        """Parse live registry data"""
        try:
            print("[Registry] Starting live registry collection...")
            from Artifacts_Collectors.Regclaw import parse_live_registry
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
            if artifacts_dir:
                db_path = os.path.join(artifacts_dir, 'registry_data.db')
            else:
                db_path = None
            parse_live_registry(case_root=case_root, db_path=db_path)
            print("[Registry] Registry data collected successfully")
            # Load the data into the UI using the correct method
            self.load_registry_data_from_db()
        except Exception as e:
            print(f"[Registry Error] {str(e)}")
            raise
    
    def parse_perfetch(self):
        """Parse prefetch files"""
        try:
            print("[Prefetch] Starting prefetch collection...")
            from Artifacts_Collectors.Prefetch_claw import prefetch_claw
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            prefetch_claw(case_path=case_root, offline_mode=False)
            print("[Prefetch] Prefetch data collected successfully")
            # Load the data into the UI using the correct method
            self.load_data_from_Prefetch()
        except Exception as e:
            print(f"[Prefetch Error] {str(e)}")
            raise
    
    def parse_logs(self):
        """Parse Windows event logs"""
        try:
            print("[Logs] Starting Windows event logs collection...")
            from Artifacts_Collectors.WinLog_Claw import main as collect_logs
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            collect_logs(case_path=case_root)
            print("[Logs] Event logs collected successfully")
            # Load the data into the UI using the correct method
            self.load_all_logs()
        except Exception as e:
            print(f"[Logs Error] {str(e)}")
            raise
            
    def parse_shimcache(self):
        """Parse ShimCache data"""
        try:
            print("[ShimCache] Starting ShimCache collection...")
            from Artifacts_Collectors.shimcash_claw import ShimCacheParser
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
            
            # Set the database path based on case directory if available
            if artifacts_dir:
                db_path = os.path.join(artifacts_dir, 'shimcache.db')
            else:
                db_path = 'shimcache.db'
                
            # Initialize and run the ShimCache parser
            parser = ShimCacheParser(db_path)
            parser.run()
            print("[ShimCache] ShimCache data collected successfully")
            
            # Load the data into the UI
            self.load_shimcache_data()
        except Exception as e:
            print(f"[ShimCache Error] {str(e)}")
            import traceback
            traceback.print_exc()
            raise
    
    def parse_offline_lnk_files(self):
        """Parse offline LNK files and Jump Lists using the offline module"""
        try:
            print("[Offline LNK] Starting offline LNK and Jump Lists analysis...")
            from Artifacts_Collectors.offlineACJL import A_CJL_LNK_Claw
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            
            # Call the offline LNK analysis function with case_root
            A_CJL_LNK_Claw(case_root=case_root)
            print("[Offline LNK] Offline LNK and Jump Lists analyzed successfully")
            
            # Load the data into the UI
            self.load_data_from_database_lnkAJL()
            self.load_data_from_database_CJL()
        except Exception as e:
            print(f"[Offline LNK Error] {str(e)}")
            raise
    
    def parse_offline_prefetch(self):
        """Parse offline prefetch files"""
        try:
            print("[Offline Prefetch] Starting offline prefetch analysis...")
            from Artifacts_Collectors.Prefetch_claw import prefetch_claw
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            prefetch_claw(case_path=case_root, offline_mode=True)
            print("[Offline Prefetch] Offline prefetch analyzed successfully")
            # Load the data into the UI using the correct method
            self.load_data_from_Prefetch()
        except Exception as e:
            print(f"[Offline Prefetch Error] {str(e)}")
            raise
    
    def parse_offline_registry(self):
        """Parse offline registry files using the offline registry module"""
        try:
            print("[Offline Registry] Starting offline registry analysis...")
            from Artifacts_Collectors.offline_RegClaw import reg_Claw
            case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
            
            # Call the offline registry analysis function
            reg_Claw(case_root=case_root, offline_mode=True)
            print("[Offline Registry] Offline registry analyzed successfully")
            
            # Load the data into the UI using the correct method
            self.load_registry_data_from_db()
        except Exception as e:
            print(f"[Offline Registry Error] {str(e)}")
            raise

    def parse_all_live_artifacts(self):
        """Enhanced live artifact collection with loading dialog"""
        try:
            # Import the loading dialog
            from ui.Loading_dialog import LoadingDialog
            
            # Create enhanced loading dialog
            dialog = LoadingDialog(
                title="CROW EYE SYSTEM",
                parent=self.main_window
            )
            
            # Define the collection steps
            steps = [
                "Initializing artifact collection",
                "Collecting LNK files and Jump Lists",
                "Collecting Registry data", 
                "Collecting Prefetch files",
                "Collecting Event Logs",
                "Collecting ShimCache data",
                "Loading data into GUI"
            ]
            
            dialog.set_steps(steps)
            dialog.show()
            dialog.start_log_capture()
            
            try:
                print("[Open Case] Starting full live analysis...")
                
                # Step 1: Initialize
                dialog.update_step(0, " INITIALIZING ARTIFACT COLLECTION")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                print("[LNK] Collecting LNK and Jump Lists...")
                
                # Step 2: LNK and Jump Lists
                dialog.update_step(1, " COLLECTING LNK FILES AND JUMP LISTS")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                try:
                    # Import and call the LNK collection function
                    from Artifacts_Collectors.A_CJL_LNK_Claw import A_CJL_LNK_Claw
                    case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                    A_CJL_LNK_Claw(case_path=case_root, offline_mode=False)
                    print("[LNK] LNK and Jump Lists collected successfully")
                except Exception as e:
                    print(f"[LNK Error] {str(e)}")
                
                # Step 3: Registry data
                dialog.update_step(2, " COLLECTING REGISTRY DATA")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                try:
                    print("[Registry] Collecting live registry data...")
                    # Import and call the registry collection function
                    from Artifacts_Collectors.Regclaw import parse_live_registry
                    case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                    artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
                    if artifacts_dir:
                        db_path = os.path.join(artifacts_dir, 'registry_data.db')
                    else:
                        db_path = None
                    parse_live_registry(case_root=case_root, db_path=db_path)
                    print("[Registry] Registry data collected successfully")
                except Exception as e:
                    print(f"[Registry Error] {str(e)}")
                
                # Step 4: Prefetch files
                dialog.update_step(3, " COLLECTING PREFETCH FILES")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                try:
                    print("[Prefetch] Collecting prefetch data...")
                    # Import and call the prefetch collection function
                    from Artifacts_Collectors.Prefetch_claw import prefetch_claw
                    case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                    prefetch_claw(case_path=case_root, offline_mode=False)
                    print("[Prefetch] Prefetch data collected successfully")
                except Exception as e:
                    print(f"[Prefetch Error] {str(e)}")
                
                # Step 5: Event logs
                dialog.update_step(4, " COLLECTING EVENT LOGS")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                try:
                    print("[Logs] Collecting Windows event logs...")
                    # Import and call the logs collection function
                    from Artifacts_Collectors.WinLog_Claw import main as collect_logs
                    case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                    collect_logs(case_path=case_root)
                    print("[Logs] Event Logs collected successfully")
                except Exception as e:
                    print(f"[Logs Error] {str(e)}")
                
                # Step 6: ShimCache data
                dialog.update_step(5, " COLLECTING SHIMCACHE DATA")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                try:
                    print("[ShimCache] Collecting ShimCache data...")
                    # Import and call the ShimCache collection function
                    from Artifacts_Collectors.shimcash_claw import ShimCacheParser
                    case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                    artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
                    if artifacts_dir:
                        db_path = os.path.join(artifacts_dir, 'shimcache.db')
                    else:
                        db_path = 'shimcache.db'
                    parser = ShimCacheParser(db_path)
                    parser.run()
                    print("[ShimCache] ShimCache data collected successfully")
                except Exception as e:
                    print(f"[ShimCache Error] {str(e)}")
                
                print("[Open Case] Artifact collection finished. Loading data into UI...")
                
                # Step 7: Load data into GUI
                dialog.update_step(6, " LOADING DATA INTO GUI")
                QtWidgets.QApplication.processEvents()  # Force GUI update
                try:
                    self.load_all_data_internal()
                    print("[GUI] All data loaded successfully")
                except Exception as e:
                    print(f"[GUI Error] Failed to load data into UI: {str(e)}")
                
                # Show completion
                dialog.show_completion("ALL ARTIFACTS COLLECTED SUCCESSFULLY")
                print("[Open Case] Full live analysis and data loading completed.")
                print("\033[92m[Live Artifacts] All live artifacts have been collected and loaded successfully\033[0m")
                
                # Keep dialog open briefly
                QtCore.QTimer.singleShot(2500, dialog.close)
                
                # Show success message
                def show_success():
                    QtWidgets.QMessageBox.information(
                        self.main_window,
                        "Live Artifacts Collection",
                        "All live artifacts have been collected and loaded successfully."
                    )
                
                QtCore.QTimer.singleShot(3000, show_success)
                
            except Exception as e:
                error_msg = f"Artifact collection failed: {str(e)}"
                dialog.add_log_message(f"[Error] {error_msg}")
                print(f"[Error] {error_msg}")
                
                # Keep error dialog open longer
                QtCore.QTimer.singleShot(4000, dialog.close)
                
                # Show error message
                def show_error():
                    QtWidgets.QMessageBox.critical(
                        self.main_window,
                        "Live Artifacts Collection",
                        f"Failed to collect all artifacts: {str(e)}"
                    )
                
                QtCore.QTimer.singleShot(4500, show_error)
                raise
                
            finally:
                dialog.stop_log_capture()
                
        except ImportError:
            print("Warning: Could not load loading dialog, using fallback")
            # Fallback to original implementation
            print("[Open Case] Starting full live analysis...")
            
            # Step 1: Collect all artifacts (without loading data into UI)
            try:
                print("[LNK] Collecting LNK and Jump Lists...")
                from Artifacts_Collectors.A_CJL_LNK_Claw import A_CJL_LNK_Claw
                case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                A_CJL_LNK_Claw(case_path=case_root, offline_mode=False)
            except Exception as e:
                print(f"[LNK Error] {str(e)}")
            try:
                print("[Registry] Collecting live registry data...")
                # Import and call the registry collection function
                from Artifacts_Collectors.Regclaw import parse_live_registry
                case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
                if artifacts_dir:
                    db_path = os.path.join(artifacts_dir, 'registry_data.db')
                else:
                    db_path = None
                parse_live_registry(case_root=case_root, db_path=db_path)
            except Exception as e:
                print(f"[Registry Error] {str(e)}")
            try:
                print("[Prefetch] Collecting prefetch data...")
                from Artifacts_Collectors.Prefetch_claw import prefetch_claw
                case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                prefetch_claw(case_path=case_root, offline_mode=False)
            except Exception as e:
                print(f"[Prefetch Error] {str(e)}")
            try:
                print("[Logs] Collecting Windows event logs...")
                from Artifacts_Collectors.WinLog_Claw import main as collect_logs
                case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                collect_logs(case_path=case_root)
            except Exception as e:
                print(f"[Logs Error] {str(e)}")
            try:
                print("[ShimCache] Collecting ShimCache data...")
                from Artifacts_Collectors.shimcash_claw import ShimCacheParser
                case_root = self.case_paths.get('case_root') if hasattr(self, 'case_paths') and self.case_paths else None
                artifacts_dir = self.case_paths.get('artifacts_dir') if hasattr(self, 'case_paths') and self.case_paths else None
                if artifacts_dir:
                    db_path = os.path.join(artifacts_dir, 'shimcache.db')
                else:
                    db_path = 'shimcache.db'
                parser = ShimCacheParser(db_path)
                parser.run()
                print("[ShimCache] ShimCache data collected successfully")
            except Exception as e:
                print(f"[ShimCache Error] {str(e)}")
            
            print("[Open Case] Artifact collection finished. Loading data into UI...")
            
            # Step 2: Load all collected data into UI tables
            try:
                self.load_all_data_internal()
            except Exception as e:
                print(f"[Open Case Error] Failed to load data into UI: {str(e)}")
            
            print("[Open Case] Full live analysis and data loading completed.")
    
    def load_all_data(self, loading_dialog=None):
        """Load all data with enhanced loading dialog"""
        try:
            # Import the loading dialog
            from ui.Loading_dialog import LoadingDialog
            
            # Create enhanced loading dialog
            dialog = LoadingDialog(
                title="CROW EYE SYSTEM",
                parent=self.main_window
            )
            
            # Define the steps
            steps = [
                "Loading LNK and Jump List data",
                "Loading Custom Jump Lists", 
                "Loading Registry data",
                "Loading File Activity data",
                "Loading Prefetch data",
                "Loading Event Logs",
                "Loading ShimCache data",
                "Loading Registry Database"
            ]
            
            dialog.set_steps(steps)
            dialog.show()
            dialog.start_log_capture()
            
            try:
                # Step 1: Loading LNK data
                dialog.update_step(0, " LOADING LNK AND JUMP LIST DATA")
                self.load_data_from_database_lnkAJL()
                
                # Step 2: Loading Custom Jump Lists
                dialog.update_step(1, " LOADING CUSTOM JUMP LISTS")
                self.load_data_from_database_CJL()
                
                # Step 3: Loading Registry data
                dialog.update_step(2, " LOADING REGISTRY DATA")
                self.load_allReg_data()
                
                # Step 4: Loading File Activity data
                dialog.update_step(3, " LOADING FILE ACTIVITY DATA")
                print("[File Activity] Starting to load File Activity Data...")
                self.load_files_activity()
                print("[File Activity] Completed loading File Activity Data")
                
                # Step 5: Loading Prefetch data
                dialog.update_step(4, " LOADING PREFETCH DATA")
                print("[Prefetch] Starting to load Prefetch Data...")
                self.load_data_from_Prefetch()
                print("[Prefetch] Completed loading Prefetch Data")
                
                # Step 6: Loading Event Logs
                dialog.update_step(5, " LOADING EVENT LOGS")
                print("[Logs] Starting to load Event Logs...")
                self.load_all_logs()
                print("[Logs] Completed loading Event Logs")
                
                # Step 7: Loading ShimCache data
                dialog.update_step(6, " LOADING SHIMCACHE DATA")
                print("[ShimCache] Starting to load ShimCache Data...")
                self.load_shimcache_data()
                print("[ShimCache] Completed loading ShimCache Data")
                
                # Step 8: Loading Registry Database
                dialog.update_step(7, " LOADING REGISTRY DATABASE")
                print("[Registry] Starting to load Registry Database...")
                self.load_registry_data_from_db()
                print("[Registry] Completed loading Registry Database")
                
                # Show completion
                dialog.show_completion("ALL DATA LOADED SUCCESSFULLY")
                print("\033[92m\nData has been loaded into the GUI Successfully\033[0m")
                
                # Keep dialog open briefly to show completion
                QtCore.QTimer.singleShot(2000, dialog.close)
                
            except Exception as e:
                error_msg = f"Error loading data: {str(e)}"
                dialog.add_log_message(f"[Error] {error_msg}")
                print(f"[Error] {error_msg}")
                QtWidgets.QApplication.processEvents()
                
                # Keep error dialog open longer
                QtCore.QTimer.singleShot(4000, dialog.close)
                raise
                
            finally:
                dialog.stop_log_capture()
                
        except ImportError:
            print("Warning: Could not load loading dialog, using fallback")
            # Fallback to existing implementation
            if loading_dialog:
                self.load_all_data_with_progress(loading_dialog)
            else:
                self.run_analysis_with_loading("Loading All Data...", self.load_all_data_internal, run_in_thread=False)
    
    def load_all_data_internal(self):
        """Internal function to load all data (called by the loading screen)"""
        try:
            self.load_data_from_database_lnkAJL()
        except Exception as e:
            print(f"[LNK Error] Couldn't load JumpLists: {str(e)}")

        try:
            self.load_data_from_database_CJL()
        except Exception as e:
            print(f"[CustomJL Error] Couldn't load Custom JumpLists: {str(e)}")

        try:
            self.load_allReg_data()
        except Exception as e:
            print(f"[Registry Error] Couldn't load registry data: {str(e)}")

        try:
            self.load_files_activity()
        except Exception as e:
            print(f"[File Activity Error] Couldn't load file history: {str(e)}")

        try:
            self.load_all_logs()
        except Exception as e:
            print(f"[Logs Error] Couldn't load event logs: {str(e)}")

        try:
            self.load_data_from_Prefetch()
        except Exception as e:
            print(f"[Prefetch Error] Couldn't load prefetch data: {str(e)}")
            
        try:
            self.load_shimcache_data()
        except Exception as e:
            print(f"[ShimCache Error] Couldn't load ShimCache data: {str(e)}")
        try:
            self.load_registry_data_from_db()
        except Exception as e:
            print(f"[Registry Error] Couldn't load registry data: {str(e)}")
        
        print("\033[92m\nData has been loaded into the GUI Successfully\033[0m")

    def load_all_data_with_progress(self, loading_dialog):
        """Load all data with progress updates using the enhanced dialog"""
        steps = [
            "Loading LNK and Jump List data",
            "Loading Custom Jump Lists", 
            "Loading Registry data",
            "Loading Prefetch data",
            "Loading Event Logs",
            "Loading ShimCache data"
        ]
        
        try:
            # Update step 1: Loading LNK data
            loading_dialog.update_step(0, " Loading LNK and Jump List data...")
            self.load_data_from_database_lnkAJL()
            
            # Update step 2: Loading Custom Jump Lists
            loading_dialog.update_step(1, " Loading Custom Jump Lists...")
            self.load_data_from_database_CJL()
            
            # Update step 3: Loading Registry data
            loading_dialog.update_step(2, " Loading Registry data...")
            self.load_allReg_data()
            
            # Update step 4: Loading Prefetch data
            loading_dialog.update_step(3, " Loading Prefetch data...")
            print("[File Activity] Starting to load File Activity Data...")
            self.load_files_activity()
            print("[File Activity] Completed loading File Activity Data")
            
            # Load Event Logs
            loading_dialog.status_label.setText("Loading Event Logs...")
            QApplication.processEvents()
            print("[Logs] Starting to load Event Logs...")
            self.load_all_logs()
            print("[Logs] Completed loading Event Logs")
            
            # Load Prefetch Data
            loading_dialog.status_label.setText("Loading Prefetch Data...")
            QApplication.processEvents()
            print("[Prefetch] Starting to load Prefetch Data...")
            self.load_data_from_Prefetch()
            print("[Prefetch] Completed loading Prefetch Data")
            
            # Load Registry Data from DB
            loading_dialog.status_label.setText("Loading Registry Database...")
            QApplication.processEvents()
            print("[Registry] Starting to load Registry Database...")
            self.load_registry_data_from_db()
            print("[Registry] Completed loading Registry Database")
            
            # Load ShimCache Data
            loading_dialog.update_step(5, " Loading ShimCache data...")
            QApplication.processEvents()
            print("[ShimCache] Starting to load ShimCache Data...")
            self.load_shimcache_data()
            print("[ShimCache] Completed loading ShimCache Data")
            
            loading_dialog.status_label.setText("Data loading completed successfully!")
            QApplication.processEvents()
            
            print("\033[92m\nData has been loaded into the GUI Successfully\033[0m")
            
        except Exception as e:
            error_msg = f"Error loading data: {str(e)}"
            loading_dialog.status_label.setText(error_msg)
            print(f"[Error] {error_msg}")
            QApplication.processEvents()
            print(f"[Error] Failed to load data: {str(e)}")

    def on_log_message(self, category, message):
        """Handle log message signal"""
        # Format the message based on category
        if category == "Error":
            formatted_message = f"<span style='color:#ff5555;'>[ERROR] {message}</span>"
        elif category == "Warning":
            formatted_message = f"<span style='color:#ffaa00;'>[WARNING] {message}</span>"
        elif category == "Success":
            formatted_message = f"<span style='color:#55ff55;'>[SUCCESS] {message}</span>"
        else:
            formatted_message = f"<span style='color:#aaaaaa;'>[{category}]</span> {message}"
        
        # Add the message to the log display
        self.log_display.append(formatted_message)
        
        # Scroll to the bottom
        scrollbar = self.log_display.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())
        
        # Process events to ensure the UI updates
        QApplication.processEvents()

    def export_table_to_json(self, table_widget, file_path=None):
        """Export the contents of a table widget to a JSON file"""
        try:
            # Get the data from the table
            data = []
            headers = []
            
            # Get headers
            for col in range(table_widget.columnCount()):
                header_item = table_widget.horizontalHeaderItem(col)
                if header_item:
                    headers.append(header_item.text())
                else:
                    headers.append(f"Column {col}")
            
            # Get data
            for row in range(table_widget.rowCount()):
                row_data = {}
                for col in range(table_widget.columnCount()):
                    item = table_widget.item(row, col)
                    if item:
                        row_data[headers[col]] = item.text()
                    else:
                        row_data[headers[col]] = ""
                data.append(row_data)
            
            # If no file path provided, ask user for one
            if not file_path:
                file_path, _ = QFileDialog.getSaveFileName(
                    self.main_window,
                    "Save JSON File",
                    "",
                    "JSON Files (*.json)"
                )
                
            if not file_path:  # User cancelled
                return False
                
            # Ensure file has .json extension
            if not file_path.lower().endswith('.json'):
                file_path += '.json'
                
            # Write to file
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=4, ensure_ascii=False)
                
            print(f"[Export] Successfully exported table to JSON: {file_path}")
            return True
            
        except Exception as e:
            print(f"[Export Error] Failed to export table to JSON: {str(e)}")
            QMessageBox.critical(
                self.main_window,
                "Export Error",
                f"Failed to export table to JSON: {str(e)}"
            )
            return False
    
    def export_table_to_csv(self, table_widget, file_path=None):
        """Export the contents of a table widget to a CSV file"""
        try:
            import csv
            
            # If no file path provided, ask user for one
            if not file_path:
                file_path, _ = QFileDialog.getSaveFileName(
                    self.main_window,
                    "Save CSV File",
                    "",
                    "CSV Files (*.csv)"
                )
                
            if not file_path:  # User cancelled
                return False
                
            # Ensure file has .csv extension
            if not file_path.lower().endswith('.csv'):
                file_path += '.csv'
                
            # Get headers
            headers = []
            for col in range(table_widget.columnCount()):
                header_item = table_widget.horizontalHeaderItem(col)
                if header_item:
                    headers.append(header_item.text())
                else:
                    headers.append(f"Column {col}")
            
            # Write to file
            with open(file_path, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(headers)
                
                # Write data rows
                for row in range(table_widget.rowCount()):
                    row_data = []
                    for col in range(table_widget.columnCount()):
                        item = table_widget.item(row, col)
                        if item:
                            row_data.append(item.text())
                        else:
                            row_data.append("")
                    writer.writerow(row_data)
            print(f"[Export] Successfully exported table to CSV: {file_path}")
            return True
            
        except Exception as e:
            print(f"[Export Error] Failed to export table to CSV: {str(e)}")
            QMessageBox.critical(
                self.main_window,
                "Export Error",
                f"Failed to export table to CSV: {str(e)}"
            )
            return False
    
    def export_all_tables(self):
        """Export all tables to JSON and CSV files"""
        try:
            # Ask user for export directory
            export_dir = QFileDialog.getExistingDirectory(
                self.main_window,
                "Select Export Directory",
                "",
                QFileDialog.ShowDirsOnly
            )
            
            if not export_dir:  # User cancelled
                return
                
            # Create a timestamp for the export
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            
            # Create a subdirectory for this export
            export_subdir = os.path.join(export_dir, f"CrowEye_Export_{timestamp}")
            os.makedirs(export_subdir, exist_ok=True)
            
            # Define the tables to export
            tables = {
                "LNK_Files": self.LNK_table,
                "Custom_JumpLists": self.Clj_table,
                "Prefetch": self.Prefetch_table,
                "SystemLogs": self.SystemLogs_table,
                "SecurityLogs": self.SecurityLogs_table,
                "ApplicationLogs": self.AppLogs_table,
                "ComputerName": self.computerName_table,
                "TimeZone": self.TimeZone_table,
                "NetworkInterfaces": self.NetworkInterface_table,
                "NetworkLists": self.NetworkLists_table,
                "SystemServices": self.tableWidget_2,
                "MachineRun": self.MachineRun_table,
                "MachineRunOnce": self.MachineRunOnce_tabel,
                "UserRun": self.UserRun_table,
                "UserRunOnce": self.UserRunOnce_table,
                "LastUpdate": self.LastUpdate_table,
                "LastUpdateInfo": self.LastUpdateInfo_table,
                "ShutDown": self.ShutDown_table,
                "ShimCache": self.ShimCache_main_table,
                "BrowserHistory": self.Browser_history_table,
                "USBDevices": self.tableWidget_3,
                "USBInstances": self.tableWidget_4,
                "USBProperties": self.tableWidget_5,
                "USBStorageDevices": self.tableWidget_6,
                "USBStorageVolumes": self.tableWidget_7,
                "RecentDocs": self.RecentDocs_table,
                "SearchExplorer": self.SearchViaExplorer_table,
                "OpenSaveMRU": self.OpenSaveMRU_table,
                "LastSaveMRU": self.LastSaveMRU_table,
                "TypedPaths": self.TypedPath_table,
                "BAM": self.Bam_table,
                "DAM": self.Dam_table,
                "InstalledSoftware": self.tableWidget
            }
            
            # Create subdirectories for JSON and CSV
            json_dir = os.path.join(export_subdir, "JSON")
            csv_dir = os.path.join(export_subdir, "CSV")
            os.makedirs(json_dir, exist_ok=True)
            os.makedirs(csv_dir, exist_ok=True)
            
            # Export each table
            exported_count = 0
            for table_name, table_widget in tables.items():
                # Skip empty tables
                if table_widget.rowCount() == 0:
                    print(f"[Export] Skipping empty table: {table_name}")
                    continue
                    
                # Export to JSON
                json_path = os.path.join(json_dir, f"{table_name}.json")
                if self.export_table_to_json(table_widget, json_path):
                    exported_count += 1
                    
                # Export to CSV
                csv_path = os.path.join(csv_dir, f"{table_name}.csv")
                if self.export_table_to_csv(table_widget, csv_path):
                    exported_count += 1
            
            # Create a summary file
            summary_path = os.path.join(export_subdir, "export_summary.txt")
            with open(summary_path, 'w', encoding='utf-8') as f:
                f.write(f"CrowEye Export Summary\n")
                f.write(f"=====================\n\n")
                f.write(f"Export Date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                if hasattr(self, 'case_paths') and self.case_paths:
                    f.write(f"Case Name: {os.path.basename(self.case_paths['case_root'])}\n")
                f.write(f"Tables Exported: {len([t for t in tables.values() if t.rowCount() > 0])}\n")
                f.write(f"Total Files Created: {exported_count}\n\n")
                f.write(f"Files are available in JSON and CSV formats in the respective directories.\n")
            
            QMessageBox.information(
                self.main_window,
                "Export Complete",
                f"Successfully exported {exported_count} files to:\n{export_subdir}"
            )
            
        except Exception as e:
            print(f"[Export Error] Failed to export tables: {str(e)}")
            QMessageBox.critical(
                self.main_window,
                "Export Error",
                f"Failed to export tables: {str(e)}"
            )

                    
    def search_tables(self):
        search_text = self.search_input.text().strip()
        print(f"DEBUG: search_tables called with search_text: '{search_text}'")
        if not search_text:
            QMessageBox.information(self.main_window, "Search", "Please enter text to search for.")
            return

        self.loading_label.show()
        self.loading_movie.start()
        self.clear_search_results()

        tables = self.find_all_table_widgets()
        print(f"DEBUG: Found {len(tables)} tables to search.")

        self.thread = QThread()
        self.worker = SearchWorker(tables, search_text)
        self.worker.moveToThread(self.thread)
        self.thread.started.connect(self.worker.run)
        self.worker.finished.connect(self.on_search_finished)
        self.worker.finished.connect(self.thread.quit)
        self.worker.finished.connect(self.worker.deleteLater)
        self.thread.finished.connect(self.thread.deleteLater)
        self.thread.start()

    def on_search_finished(self, results):
        self.search_results = results
        print(f"DEBUG: on_search_finished called with {len(self.search_results)} results.")
        self.loading_movie.stop()
        self.loading_label.hide()

        # Clear any existing highlights and queue
        self.highlight_queue.clear()
        
        if self.search_results:
            # Initialize the current result index
            self.current_result_index = 0
            print(f"DEBUG: Initial current_result_index: {self.current_result_index}")
            
            # Update the search result label
            self.update_search_result_label()
            
            # Enable navigation buttons
            self.prev_result_button.setEnabled(len(self.search_results) > 1)
            self.next_result_button.setEnabled(len(self.search_results) > 1)
            if hasattr(self, '_search_button'):
                self._search_button.setEnabled(True)
                
            # Trigger highlighting of the first result
            self.highlight_current_result()
            
            # Show message after highlighting is queued
            QMessageBox.information(self.main_window, "Search Results",
                                  f"Found {len(self.search_results)} matches.")
        else:
            # No results found
            self.search_label.setText("Search:")
            QMessageBox.information(self.main_window, "Search Results", "No matches found.")
            self.prev_result_button.setEnabled(False)
            self.next_result_button.setEnabled(False)
            if hasattr(self, '_search_button'):
                self._search_button.setEnabled(False)

    
    def find_all_table_widgets(self):
        """Find all QTableWidget instances in the application"""
        tables = []
        # Find all attributes that are table widgets
        for attr_name in dir(self):
            attr = getattr(self, attr_name)
            if isinstance(attr, QtWidgets.QTableWidget):
                tables.append(attr)
        return tables
        
    def enable_sorting_for_all_tables(self):
        """Enable sorting for all table widgets in the application"""
        tables = self.find_all_table_widgets()
        for table in tables:
            # Enable sorting for the table
            table.setSortingEnabled(True)
            
            # Apply header styling to show sort indicators better
            header = table.horizontalHeader()
            header.setHighlightSections(True)
            
            # Set header style to make sort indicators more visible - use UNIFIED_TABLE_STYLE for consistency
            header.setStyleSheet(CrowEyeStyles.UNIFIED_TABLE_STYLE)
            
            # Connect header click event to sort indicator update
            header.sectionClicked.connect(lambda logicalIndex, table=table: 
                                         self.update_sort_indicator(table, logicalIndex))
    
    def update_sort_indicator(self, table, column_index):
        """Update the sort indicator when a column header is clicked"""
        # Get the current sort order
        header = table.horizontalHeader()
        
        # Toggle sort order
        if header.sortIndicatorSection() == column_index:
            # If clicking the same column, toggle the sort order
            if header.sortIndicatorOrder() == Qt.AscendingOrder:
                table.sortItems(column_index, Qt.DescendingOrder)
            else:
                table.sortItems(column_index, Qt.AscendingOrder)
        else:
            # If clicking a different column, default to ascending order
            table.sortItems(column_index, Qt.AscendingOrder)
    
    def highlight_current_result(self, process_immediately=False):
        """Adds a highlight request to the queue.
        
        Args:
            process_immediately (bool): If True, process the highlight immediately instead of waiting for the timer.
            
        Returns:
            bool: True if a highlight request was added to the queue, False otherwise.
        """
        if 0 <= self.current_result_index < len(self.search_results):
            # Clear the queue to avoid backlog of highlights
            self.highlight_queue.clear()
            self.highlight_queue.append(self.current_result_index)
            
            # Process immediately if requested
            if process_immediately:
                print(f"DEBUG: Processing highlight immediately for result {self.current_result_index}")
                self.process_highlight_queue(force=True)
                return True
                
            # Otherwise ensure the timer is running
            if not self.highlight_timer.isActive():
                self.highlight_timer.start()
            return True
        return False

    def process_highlight_queue(self, force=False):
        """Processes one highlight request from the queue.
        
        Args:
            force (bool): If True, process the queue even if is_processing_highlight is True.
        """
        if (self.is_processing_highlight and not force) or not self.highlight_queue:
            return

        self.is_processing_highlight = True
        try:
            result_index = self.highlight_queue.popleft()
            if not (0 <= result_index < len(self.search_results)):
                return

            # Set current_result_index to the index we're processing
            self.current_result_index = result_index
            
            table, row, _ = self.search_results[result_index]
            if not table or not isinstance(table, QtWidgets.QTableWidget):
                return

            print(f"DEBUG: Processing highlight for table {table.objectName()}, row {row}")
            
            # For all tables, use the enhanced make_table_visible method
            self.make_table_visible(table)
            
            # Process events to ensure UI updates
            QtWidgets.QApplication.processEvents()
            
            # Wait for the table to become visible with a timeout
            start_time = QtCore.QTime.currentTime()
            max_wait_time = 2000  # Increase timeout to 2 seconds for complex nested tabs
            while not table.isVisible() and start_time.msecsTo(QtCore.QTime.currentTime()) < max_wait_time:
                QtWidgets.QApplication.processEvents()
                QtCore.QThread.msleep(50)
            
            # Ensure the table is actually visible before proceeding
            if not table.isVisible():
                print(f"WARNING: Table {table.objectName()} is still not visible after waiting")
                
                # Special handling for LNK_table
                if table.objectName() == "LNK_table" and hasattr(self, 'main_tab') and hasattr(self, 'LNK_AL_Tab'):
                    print(f"DEBUG: Special retry for LNK_table")
                    # Force the main tab to show LNK_AL_Tab
                    for i in range(self.main_tab.count()):
                        if self.main_tab.widget(i) is self.LNK_AL_Tab:
                            self.main_tab.setCurrentIndex(i)
                            self.main_tab.update()
                            self.main_tab.repaint()
                            break
                    
                    # Force application to process all pending events
                    QtWidgets.QApplication.processEvents()
                    QtCore.QThread.msleep(500)  # Much longer delay
                    QtWidgets.QApplication.processEvents()
                    
                    # Try to force focus and visibility
                    self.LNK_AL_Tab.show()
                    self.LNK_AL_Tab.raise_()
                    self.LNK_AL_Tab.setFocus()
                    self.LNK_AL_Tab.update()
                    self.LNK_AL_Tab.repaint()
                    QtWidgets.QApplication.processEvents()
                    
                    table.show()
                    table.raise_()
                    table.setFocus()
                    table.update()
                    table.repaint()
                    QtWidgets.QApplication.processEvents()
                
                # Try to force focus on the table's parent
                parent = table.parentWidget()
                if parent:
                    parent.show()
                    parent.raise_()
                    parent.setFocus()
                    parent.update()
                    parent.repaint()
                    QtWidgets.QApplication.processEvents()
                    QtCore.QThread.msleep(200)
                
                # If still not visible, try again with a longer delay
                if not table.isVisible():
                    print(f"ERROR: Table {table.objectName()} could not be made visible, retrying...")
                    # Use a longer delay and try again
                    QtCore.QTimer.singleShot(500, lambda: self.highlight_current_result(True))
                    return

            print(f"DEBUG: Table {table.objectName()} is now visible, proceeding with highlighting")
            
            # Clear previous selection and highlights
            table.clearSelection()

            # Scroll to and select the item
            item = table.item(row, 0)
            if item:
                # First ensure the table has focus
                table.setFocus()
                QtWidgets.QApplication.processEvents()
                
                # Scroll the item into view
                table.scrollToItem(item, QtWidgets.QAbstractItemView.ScrollHint.PositionAtCenter)
                QtWidgets.QApplication.processEvents()
                
                # Select the row
                table.selectRow(row)
                QtWidgets.QApplication.processEvents()
                
                print(f"DEBUG: Scrolled to and selected row {row} in table {table.objectName()}")
                
                # Update the search result label
                self.update_search_result_label()
                
                # Enable navigation buttons
                self.prev_result_button.setEnabled(len(self.search_results) > 1)
                self.next_result_button.setEnabled(len(self.search_results) > 1)
                if hasattr(self, '_search_button'):
                    self._search_button.setEnabled(True)
            else:
                print(f"WARNING: Could not find item at row {row}, column 0 in table {table.objectName()}")

        finally:
            self.is_processing_highlight = False

    def update_search_result_label(self):
        if self.search_results:
            self.search_label.setText(f"Result {self.current_result_index + 1} of {len(self.search_results)}")
        else:
            self.search_label.setText("Search:")
    
    def make_table_visible(self, table):
        """Make the table visible by switching to its tab, handling nested tabs."""
        print(f"DEBUG: make_table_visible called for table: {table.objectName()}")
        
        # Store the original table to check if it's visible at the end
        original_table = table
        
        # Find the direct parent widget of the table
        direct_parent = table.parentWidget()
        print(f"DEBUG: Direct parent of {table.objectName()} is {direct_parent.objectName()}")
        
        # Special handling for LNK_table
        if table.objectName() == "LNK_table":
            # Make sure we're on the LNK_AL_Tab in the main_tab
            if hasattr(self, 'main_tab') and hasattr(self, 'LNK_AL_Tab'):
                # First, ensure main_tab is visible and has focus
                self.main_tab.show()
                self.main_tab.setFocus()
                QtWidgets.QApplication.processEvents()
                
                # Find and select the LNK_AL_Tab in main_tab
                for i in range(self.main_tab.count()):
                    if self.main_tab.widget(i) is self.LNK_AL_Tab:
                        print(f"DEBUG: Setting main_tab to LNK_AL_Tab (index {i})")
                        self.main_tab.setCurrentIndex(i)
                        QtWidgets.QApplication.processEvents()
                        QtCore.QThread.msleep(200)  # Longer delay for tab switching
                        QtWidgets.QApplication.processEvents()
                        break
            
            # Force focus on the LNK_AL_Tab and then the table
            if hasattr(self, 'LNK_AL_Tab'):
                self.LNK_AL_Tab.show()
                self.LNK_AL_Tab.raise_()
                self.LNK_AL_Tab.setFocus()
                QtWidgets.QApplication.processEvents()
                QtCore.QThread.msleep(100)
                
                # Now focus on the table itself
                table.show()
                table.raise_()
                table.setFocus()
                QtWidgets.QApplication.processEvents()
            
            # Wait for the table to become visible with a timeout
            start_time = QtCore.QTime.currentTime()
            timeout_ms = 2000  # Increase timeout to 2 seconds for complex tab structures
            while not table.isVisible() and start_time.msecsTo(QtCore.QTime.currentTime()) < timeout_ms:
                QtWidgets.QApplication.processEvents()
                QtCore.QThread.msleep(50)
            
            # If still not visible, try more aggressive approach
            if not table.isVisible():
                print(f"DEBUG: Trying more aggressive approach for {table.objectName()}")
                # Try to force the main window to update
                if hasattr(self, 'main_tab'):
                    self.main_tab.update()
                if hasattr(self, 'LNK_AL_Tab'):
                    self.LNK_AL_Tab.update()
                table.update()
                QtWidgets.QApplication.processEvents()
                QtCore.QThread.msleep(200)
                
                # Last resort - try to force repaint
                if hasattr(self, 'main_tab'):
                    self.main_tab.repaint()
                if hasattr(self, 'LNK_AL_Tab'):
                    self.LNK_AL_Tab.repaint()
                table.repaint()
                QtWidgets.QApplication.processEvents()
            
            return
        
        # Special handling for the AppLogs_table which seems to have issues
        if table.objectName() == "AppLogs_table":
            # Make sure we're on the Logs tab in the main_tab
            if hasattr(self, 'main_tab') and hasattr(self, 'Logs_tab'):
                # First, ensure main_tab is visible and has focus
                self.main_tab.show()
                self.main_tab.setFocus()
                QtWidgets.QApplication.processEvents()
                
                # Find and select the Logs tab in main_tab
                for i in range(self.main_tab.count()):
                    if self.main_tab.widget(i) is self.Logs_tab:
                        print(f"DEBUG: Setting main_tab to Logs_tab (index {i})")
                        self.main_tab.setCurrentIndex(i)
                        QtWidgets.QApplication.processEvents()
                        QtCore.QThread.msleep(200)  # Longer delay for tab switching
                        QtWidgets.QApplication.processEvents()
                        break
            
            # Make sure we're on the AppLogs_tab in the tabWidget
            if hasattr(self, 'tabWidget') and hasattr(self, 'AppLogs_tab'):
                # Ensure tabWidget is visible and has focus
                self.tabWidget.show()
                self.tabWidget.setFocus()
                QtWidgets.QApplication.processEvents()
                
                # Find and select the AppLogs_tab in tabWidget
                for i in range(self.tabWidget.count()):
                    if self.tabWidget.widget(i) is self.AppLogs_tab:
                        print(f"DEBUG: Setting tabWidget to AppLogs_tab (index {i})")
                        self.tabWidget.setCurrentIndex(i)
                        QtWidgets.QApplication.processEvents()
                        QtCore.QThread.msleep(200)  # Longer delay for tab switching
                        QtWidgets.QApplication.processEvents()
                        break
            
            return
        
        # Find all tab widgets in the hierarchy for other tables
        tab_hierarchy = []
        current_widget = direct_parent
        while current_widget is not None:
            parent_widget = current_widget.parentWidget()
            if parent_widget is not None and isinstance(parent_widget, QtWidgets.QTabWidget):
                tab_hierarchy.append((parent_widget, current_widget))
                print(f"DEBUG: Found tab widget: {parent_widget.objectName()} containing {current_widget.objectName()}")
            current_widget = parent_widget
        
        # Reverse the hierarchy to start from the outermost tab widget
        tab_hierarchy.reverse()
        
        # Set each tab widget to the correct index
        for tab_widget, tab_content in tab_hierarchy:
            # Ensure the tab widget is visible and has focus
            tab_widget.show()
            tab_widget.setFocus()
            QtWidgets.QApplication.processEvents()
            
            for i in range(tab_widget.count()):
                if tab_widget.widget(i) is tab_content:
                    print(f"DEBUG: Setting {tab_widget.objectName()} to index {i} ({tab_content.objectName()})")
                    tab_widget.setCurrentIndex(i)
                    # Process events after each tab change to ensure UI updates
                    QtWidgets.QApplication.processEvents()
                    # Add a longer delay to allow the UI to update
                    QtCore.QThread.msleep(200)  # Increased delay for better reliability
                    QtWidgets.QApplication.processEvents()
                    break
        
        # Process Qt events to ensure UI updates before continuing
        QtWidgets.QApplication.processEvents()
        
        # Wait for the table to become visible with a timeout
        start_time = QtCore.QTime.currentTime()
        timeout_ms = 2000  # Increase timeout to 2 seconds for complex tab structures
        while not original_table.isVisible() and start_time.msecsTo(QtCore.QTime.currentTime()) < timeout_ms:
            QtWidgets.QApplication.processEvents()
            QtCore.QThread.msleep(50)
        
        # Verify the table is now visible
        if original_table.isVisible():
            print(f"DEBUG: Table {original_table.objectName()} is now visible")
        else:
            print(f"WARNING: Table {original_table.objectName()} is still not visible after tab changes")
            # Try more aggressive approach
            print(f"DEBUG: Trying more aggressive approach for {original_table.objectName()}")
            
            # Force update on the entire hierarchy
            for tab_widget, tab_content in tab_hierarchy:
                tab_widget.update()
                tab_content.update()
            
            if direct_parent:
                direct_parent.show()
                direct_parent.raise_()
                direct_parent.setFocus()
                direct_parent.update()
                QtWidgets.QApplication.processEvents()
                QtCore.QThread.msleep(200)
            
            original_table.show()
            original_table.raise_()
            original_table.setFocus()
            original_table.update()
            QtWidgets.QApplication.processEvents()
                
            # Final check
            if original_table.isVisible():
                print(f"DEBUG: Table {original_table.objectName()} is now visible after additional attempts")
            else:
                print(f"ERROR: Table {original_table.objectName()} could not be made visible")
                # Last resort - try again with a longer delay
                QtCore.QTimer.singleShot(300, lambda: self._check_table_visibility(original_table))
    
    def _check_table_visibility(self, table):
        """Check if a table is visible after a delay and log the result."""
        if table.isVisible():
            print(f"DEBUG: Table {table.objectName()} is now visible after delay")
        else:
            print(f"WARNING: Table {table.objectName()} is still not visible after delay")
    
    def go_to_next_result(self):
        """Navigate to the next search result"""
        if self.search_results and len(self.search_results) > 0:
            self.current_result_index = (self.current_result_index + 1) % len(self.search_results)
            print(f"DEBUG: go_to_next_result - new index: {self.current_result_index}")
            # Process the highlight immediately
            self.highlight_current_result(process_immediately=True)
    
    def go_to_previous_result(self):
        """Navigate to the previous search result"""
        if self.search_results and len(self.search_results) > 0:
            self.current_result_index = (self.current_result_index - 1 + len(self.search_results)) % len(self.search_results)
            print(f"DEBUG: go_to_previous_result - new index: {self.current_result_index}")
            # Process the highlight immediately
            self.highlight_current_result(process_immediately=True)
    
    def clear_search_results(self):
        """Clear all search results and highlighting"""
        print("DEBUG: Clearing all search results")
        
        # Clear the highlight queue and stop processing
        self.highlight_queue.clear()
        self.is_processing_highlight = False
        
        # Clear selection from all tables
        for table in self.find_all_table_widgets():
            table.clearSelection()
        
        # Reset search results
        self.search_results = []
        self.current_result_index = -1
        
        # Clear the search input
        self.search_input.clear()
        
        # Reset the search label
        self.search_label.setText("Search:")
        
        # Update navigation buttons
        if hasattr(self, 'prev_result_button'):
            self.prev_result_button.setEnabled(False)
        if hasattr(self, 'next_result_button'):
            self.next_result_button.setEnabled(False)
        if hasattr(self, '_search_button'):
            self._search_button.setEnabled(False)
                    

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Crow_Eye = QtWidgets.QMainWindow()
    ui = Ui_Crow_Eye()
    ui.setupUi(Crow_Eye)
    Crow_Eye.showMaximized()
    
    # Try to load the last case first
    # load_last_case will only return False if there's no last case file
    # or if the case directory doesn't exist
    last_case_loaded = ui.load_last_case()
    
    # Only show the case dialog if there's no last case to load
    if not last_case_loaded:
        print("[Info] No valid last case found. Showing case dialog.")
        # Fallback: directly open the case selection flow
        ui.open_existing_case()
    
    sys.exit(app.exec_())